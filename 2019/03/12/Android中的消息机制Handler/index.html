<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Android中的消息机制Handler | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="什么是Handler？1234Handler是安卓消息机制的一个上层接口。handler通过发送和处理Message和Runnable对象来关联相对应线程的MessageQueue。1.可以让对应的Message和Runnable在未来某个时间点进行相应处理。2.让自己想要处理的耗时操作放在子线程，让更新ui的操作放在主线程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android中的消息机制Handler">
<meta property="og:url" content="http://example.com/2019/03/12/Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6Handler/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="什么是Handler？1234Handler是安卓消息机制的一个上层接口。handler通过发送和处理Message和Runnable对象来关联相对应线程的MessageQueue。1.可以让对应的Message和Runnable在未来某个时间点进行相应处理。2.让自己想要处理的耗时操作放在子线程，让更新ui的操作放在主线程。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-03-12T15:59:00.000Z">
<meta property="article:modified_time" content="2019-03-13T01:18:28.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="消息机制">
<meta property="article:tag" content="Handler">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Android中的消息机制Handler" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/12/Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6Handler/" class="article-date">
  <time datetime="2019-03-12T15:59:00.000Z" itemprop="datePublished">2019-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android中的消息机制Handler
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是Handler？"><a href="#什么是Handler？" class="headerlink" title="什么是Handler？"></a>什么是Handler？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Handler是安卓消息机制的一个上层接口。</span><br><span class="line">handler通过发送和处理Message和Runnable对象来关联相对应线程的MessageQueue。</span><br><span class="line">1.可以让对应的Message和Runnable在未来某个时间点进行相应处理。</span><br><span class="line">2.让自己想要处理的耗时操作放在子线程，让更新ui的操作放在主线程。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Handler的使用"><a href="#Handler的使用" class="headerlink" title="Handler的使用"></a>Handler的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private Handler mHandler &#x3D; new Handler() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;主线程执行的</span><br><span class="line">Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mHandler.postDelayed(runnable, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方式1:</span><br><span class="line">mHandler.post(runnable);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方式2:</span><br><span class="line">Message msg&#x3D;Message.obtain();</span><br><span class="line">msg.what&#x3D;1;</span><br><span class="line">mHandler.sendMessage(msg);</span><br></pre></td></tr></table></figure>
<p>Handler的使用主要有两种方式，如上。</p>
<p>方式1内部其实也是调用的sendMessage(msg)方法，但是它不会交给Handler的handleMessage(Message msg)来处理，而是调用Runnable的run()方法。这种主要在定时循环的需求上使用。</p>
<p>方式2是直接发了一个Message消息，最终会由Handler的handleMessage(Message msg)来处理。这种方式往往在子线程调用，用来更新UI。</p>
<p>这里可能大家会有个疑问，Looper呢？不是说Looper是用来循环读取消息的吗？在哪里呢？其实我们看ActivityThread的源码就知道了。程序启动的时候已经帮我们创建了Looper，并且开启了循环loop()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; CloseGuard defaults to true and can be quite spammy.  We</span><br><span class="line">    &#x2F;&#x2F; disable it here, but selectively enable it later (via</span><br><span class="line">   &#x2F;&#x2F; StrictMode) on debug builds, but using DropBox, not logs.</span><br><span class="line">   CloseGuard.setEnabled(false);</span><br><span class="line"></span><br><span class="line">   Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Set the reporter for event logging in libcore</span><br><span class="line">    EventLogger.setReporter(new EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br><span class="line">    final File configDir &#x3D; Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">   Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;创建Looper</span><br><span class="line">   Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">    thread.attach(false);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (false) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(new</span><br><span class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; End of event ActivityThreadMain.</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;开启循环</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们使用的时候不再创建Looper。但是我们要在子线程去轮询并处理消息呢？是需要我们自己创建Looper的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void startThread()&#123;</span><br><span class="line">   MyThread myThread&#x3D;new MyThread();</span><br><span class="line">   myThread.start();</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   Message msg&#x3D;Message.obtain();</span><br><span class="line">   myThread.handler.sendMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">    Handler handler;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line"></span><br><span class="line">        handler&#x3D;new Handler()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleMessage(Message msg) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Handler-核心类与源码分析"><a href="#Handler-核心类与源码分析" class="headerlink" title="Handler 核心类与源码分析"></a>Handler 核心类与源码分析</h2><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>Messgae是在线程之间传送的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。Message的what子段表示携带了什么类型的信息，obj字段表示携带一个Object对象。</p>
<ul>
<li>Message的创建</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Return a new Message instance from the global pool. Allows us to</span><br><span class="line"> * avoid allocating new objects in many cases.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static Message obtain() &#123;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPool !&#x3D; null) &#123;</span><br><span class="line">            Message m &#x3D; sPool;</span><br><span class="line">            sPool &#x3D; m.next;</span><br><span class="line">            m.next &#x3D; null;</span><br><span class="line">            m.flags &#x3D; 0; &#x2F;&#x2F; clear in-use flag</span><br><span class="line">            sPoolSize--;</span><br><span class="line">            return m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建消息，应避免使用new Message()的方式，而是使用obtain()。这个方法会从一个全局的pool里返回一个实例，避免分配过多的内存。其实采用了单链表存储已经回收了的Message，会每次取头结点的Message来复用，取完后第二个节点变成了头结点，单链表长度-1。当然了，没有可利用的Message，还是会默认通过new Message()来创建。</p>
<ul>
<li>Message的回收</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void recycleUnchecked() &#123;</span><br><span class="line">    &#x2F;&#x2F; Mark the message as in use while it remains in the recycled object pool.</span><br><span class="line">    &#x2F;&#x2F; Clear out all other details.</span><br><span class="line">    flags &#x3D; FLAG_IN_USE;</span><br><span class="line">    what &#x3D; 0;</span><br><span class="line">    arg1 &#x3D; 0;</span><br><span class="line">    arg2 &#x3D; 0;</span><br><span class="line">    obj &#x3D; null;</span><br><span class="line">    replyTo &#x3D; null;</span><br><span class="line">    sendingUid &#x3D; -1;</span><br><span class="line">    when &#x3D; 0;</span><br><span class="line">    target &#x3D; null;</span><br><span class="line">    callback &#x3D; null;</span><br><span class="line">    data &#x3D; null;</span><br><span class="line"></span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next &#x3D; sPool;</span><br><span class="line">            sPool &#x3D; this;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Message回收后，存储回收Message的单链表会将该Message添加为头结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需要注意区分的：</span><br><span class="line">sPool是静态的，为所有该类实例共享。</span><br><span class="line">next是非静态的，为该类每个实例单独所有。</span><br></pre></td></tr></table></figure>



<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>Handler就是消息处理者，它主要用于发送消息和处理消息。发出的消息经过一系列处理，最终会传递到Handler对象的handleMessage()方法中再分门别类的处理。</p>
<p>我们先看一下和发消息相关的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public final boolean post(Runnable r)</span><br><span class="line">&#123;</span><br><span class="line">   return  sendMessageDelayed(getPostMessage(r), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">    Message m &#x3D; Message.obtain();</span><br><span class="line">    m.callback &#x3D; r;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public final boolean sendMessage(Message msg)</span><br><span class="line">&#123;</span><br><span class="line">    return sendMessageDelayed(msg, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</span><br><span class="line">&#123;</span><br><span class="line">    if (delayMillis &lt; 0) &#123;</span><br><span class="line">        delayMillis &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">    MessageQueue queue &#x3D; mQueue;</span><br><span class="line">    if (queue &#x3D;&#x3D; null) &#123;</span><br><span class="line">        RuntimeException e &#x3D; new RuntimeException(</span><br><span class="line">                this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target &#x3D; this;</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>post(Runnable r)内部封装了一个Message(这个Message的callback被赋值了，在处理消息时来区分交给谁来处理)，最终也是调用了sendMessageAtTime(Message msg, long uptimeMillis)方法。不管是方式1还是方式2，最终都会调用queue.enqueueMessage(msg, uptimeMillis)来将消息添加到消息队列中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Subclasses must implement this to receive messages.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Handle system messages here.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback !&#x3D; null) &#123;&#x2F;&#x2F;说明是post(Runnable r)，交给run()方法处理</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback !&#x3D; null) &#123;&#x2F;&#x2F;如果我们创建Handler时传了回调</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;如果我们创建Handler没有传Callback，那么由这个方法处理，我们需要重新这个方法。</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatchMessage(Message msg)这个方法是在Looper的loop()方法中被调用的。</p>
<h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p>MessageQueue是消息队列的意思，它主要用来存放发送的消息。通过Handler发送的消息会存入MessageQueue中等待处理，每个线程中只会有一个MessageQuery 对象。</p>
<p>它通过一个单链表的数据结构来维护消息队列的，在插入和删除上比较有优势。<br>我么先看一下插入的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">    if (msg.target &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (msg.isInUse()) &#123;</span><br><span class="line">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e &#x3D; new IllegalStateException(</span><br><span class="line">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when &#x3D; when;</span><br><span class="line">        Message p &#x3D; mMessages;</span><br><span class="line">        boolean needWake;</span><br><span class="line">        if (p &#x3D;&#x3D; null || when &#x3D;&#x3D; 0 || when &lt; p.when) &#123;</span><br><span class="line">            &#x2F;&#x2F; New head, wake up the event queue if blocked.</span><br><span class="line">            msg.next &#x3D; p;</span><br><span class="line">            mMessages &#x3D; msg;</span><br><span class="line">            needWake &#x3D; mBlocked;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Inserted within the middle of the queue.  Usually we don&#39;t have to wake</span><br><span class="line">            &#x2F;&#x2F; up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">            &#x2F;&#x2F; and the message is the earliest asynchronous message in the queue.</span><br><span class="line">            needWake &#x3D; mBlocked &amp;&amp; p.target &#x3D;&#x3D; null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                prev &#x3D; p;</span><br><span class="line">                p &#x3D; p.next;</span><br><span class="line">                if (p &#x3D;&#x3D; null || when &lt; p.when) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next &#x3D; p; &#x2F;&#x2F; invariant: p &#x3D;&#x3D; prev.next</span><br><span class="line">            prev.next &#x3D; msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; We can assume mPtr !&#x3D; 0 because mQuitting is false.</span><br><span class="line">        if (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>mMessages是链表的头结点，when是消息执行的时间。</p>
<p>如果链表头结点为null(也就是链表空)或者该消息立即执行或者该消息执行的时间比头结点消息执行的时间还早，那么把该消息插入到头结点p的前面，该消息为头结点。</p>
<p>如果不是上面那几种情况，开启了死循环遍历链表。跳出死循环的条件是p == null || when &lt; p.when，也就是说某个节点为null(前一个节点就是末尾了呗)或者该节点消息执行时间大于了该消息的时间。然后将该消息插入到合适的(按执行时间when)节点。</p>
<p>下面看一下取消息的过程，但是我们需要先知道一个概念：消息屏障，也可以说是同步屏障。简单来说，设置了同步屏障之后，Handler只会处理异步消息。因为在next()方法中，会判断忽略同步的消息。那么怎么设置同步屏障呢？postSyncBarrier()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public int postSyncBarrier() &#123;</span><br><span class="line">    return postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int postSyncBarrier(long when) &#123;</span><br><span class="line">    &#x2F;&#x2F; Enqueue a new sync barrier token.</span><br><span class="line">    &#x2F;&#x2F; We don&#39;t need to wake the queue because the purpose of a barrier is to stall it.</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        final int token &#x3D; mNextBarrierToken++;</span><br><span class="line">        final Message msg &#x3D; Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when &#x3D; when;</span><br><span class="line">        msg.arg1 &#x3D; token;</span><br><span class="line"></span><br><span class="line">        Message prev &#x3D; null;</span><br><span class="line">        Message p &#x3D; mMessages;</span><br><span class="line">        if (when !&#x3D; 0) &#123;</span><br><span class="line">            while (p !&#x3D; null &amp;&amp; p.when &lt;&#x3D; when) &#123;</span><br><span class="line">                prev &#x3D; p;</span><br><span class="line">                p &#x3D; p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (prev !&#x3D; null) &#123; &#x2F;&#x2F; invariant: p &#x3D;&#x3D; prev.next</span><br><span class="line">            msg.next &#x3D; p;</span><br><span class="line">            prev.next &#x3D; msg;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            msg.next &#x3D; p;</span><br><span class="line">            mMessages &#x3D; msg;</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由源码可见，同步屏障的具体实现是在消息队列中添加了一个target==null的Message。</p>
<p>下面我们来看next()源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">    &#x2F;&#x2F; Return here if the message loop has already quit and been disposed.</span><br><span class="line">    &#x2F;&#x2F; This can happen if the application tries to restart a looper after quit</span><br><span class="line">    &#x2F;&#x2F; which is not supported.</span><br><span class="line">    final long ptr &#x3D; mPtr;</span><br><span class="line">    if (ptr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pendingIdleHandlerCount &#x3D; -1; &#x2F;&#x2F; -1 only during first iteration</span><br><span class="line">    int nextPollTimeoutMillis &#x3D; 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (nextPollTimeoutMillis !&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;把绑定在当前线程中的命令，刷新到内核中，用来阻塞线程</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            &#x2F;&#x2F; Try to retrieve the next message.  Return if found.</span><br><span class="line">            final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg &#x3D; null;</span><br><span class="line">            Message msg &#x3D; mMessages;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;如果设置了同步屏障</span><br><span class="line">            if (msg !&#x3D; null &amp;&amp; msg.target &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                do &#123;</span><br><span class="line">                    prevMsg &#x3D; msg;</span><br><span class="line">                    msg &#x3D; msg.next;</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F;消息为异步则跳出该循环</span><br><span class="line">                &#125; while (msg !&#x3D; null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            if (msg !&#x3D; null) &#123;</span><br><span class="line">                if (now &lt; msg.when) &#123;&#x2F;&#x2F;如果该消息的执行执行还没到</span><br><span class="line">                    &#x2F;&#x2F; Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                    &#x2F;&#x2F;设置一个等待时间</span><br><span class="line">                    nextPollTimeoutMillis &#x3D; (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;&#x2F;&#x2F;如果该消息执行时间到了</span><br><span class="line">                    &#x2F;&#x2F; Got a message.</span><br><span class="line">                    mBlocked &#x3D; false;</span><br><span class="line">                    if (prevMsg !&#x3D; null) &#123;</span><br><span class="line">                        prevMsg.next &#x3D; msg.next;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F;那msg肯定是头结点，把头结点的next 赋值给mMessage头结点</span><br><span class="line">                        mMessages &#x3D; msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F;移除当前msg的next指针域的引用</span><br><span class="line">                    msg.next &#x3D; null;</span><br><span class="line">                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    return msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; No more messages.</span><br><span class="line">                nextPollTimeoutMillis &#x3D; -1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Process the quit message now that all pending messages have been handled.</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; If first time idle, then get the number of idlers to run.</span><br><span class="line">            &#x2F;&#x2F; Idle handles only run if the queue is empty or if the first message</span><br><span class="line">            &#x2F;&#x2F; in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">            if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                    &amp;&amp; (mMessages &#x3D;&#x3D; null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount &#x3D; mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            if (pendingIdleHandlerCount &lt;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                mBlocked &#x3D; true;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mPendingIdleHandlers &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mPendingIdleHandlers &#x3D; new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers &#x3D; mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Run the idle handlers.</span><br><span class="line">        &#x2F;&#x2F; We only ever reach this code block during the first iteration.</span><br><span class="line">        for (int i &#x3D; 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            final IdleHandler idler &#x3D; mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] &#x3D; null; &#x2F;&#x2F; release the reference to the handler</span><br><span class="line"></span><br><span class="line">            boolean keep &#x3D; false;</span><br><span class="line">            try &#123;</span><br><span class="line">                keep &#x3D; idler.queueIdle();</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!keep) &#123;</span><br><span class="line">                synchronized (this) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Reset the idle handler count to 0 so we do not run them again.</span><br><span class="line">        pendingIdleHandlerCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; While calling an idle handler, a new message could have been delivered</span><br><span class="line">        &#x2F;&#x2F; so go back and look again for a pending message without waiting.</span><br><span class="line">        nextPollTimeoutMillis &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有消息可以处理，则取出并移除该消息。如果没有，则阻塞。阻塞方法，主要是通过native层的epoll监听文件描述符的写入事件来实现的。也就是nativePollOnce(ptr, nextPollTimeoutMillis)这个方法。通过Native层的MessageQueue阻塞nextPollTimeoutMillis毫秒的时间。</p>
<ul>
<li>nextPollTimeoutMillis=-1 一直阻塞不会超时</li>
<li>nextPollTimeoutMillis=0 不会阻塞，立即返回</li>
<li>nextPollTimeoutMillis&gt;0 阻塞nextPollTimeoutMillis毫秒，期间被唤醒则立即返回</li>
</ul>
<p>我们经常为了防止内存泄漏而调用removeCallbacksAndMessages(Object token)，这个方法内部会调用MessageQueue的下面方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void removeCallbacksAndMessages(Handler h, Object object) &#123;</span><br><span class="line">    if (h &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        Message p &#x3D; mMessages;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Remove all messages at front.</span><br><span class="line">        while (p !&#x3D; null &amp;&amp; p.target &#x3D;&#x3D; h</span><br><span class="line">                &amp;&amp; (object &#x3D;&#x3D; null || p.obj &#x3D;&#x3D; object)) &#123;</span><br><span class="line">            Message n &#x3D; p.next;</span><br><span class="line">            mMessages &#x3D; n;</span><br><span class="line">            p.recycleUnchecked();</span><br><span class="line">            p &#x3D; n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Remove all messages after front.</span><br><span class="line">        while (p !&#x3D; null) &#123;</span><br><span class="line">            Message n &#x3D; p.next;</span><br><span class="line">            if (n !&#x3D; null) &#123;</span><br><span class="line">                if (n.target &#x3D;&#x3D; h &amp;&amp; (object &#x3D;&#x3D; null || n.obj &#x3D;&#x3D; object)) &#123;</span><br><span class="line">                    Message nn &#x3D; n.next;</span><br><span class="line">                    n.recycleUnchecked();</span><br><span class="line">                    p.next &#x3D; nn;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p &#x3D; n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从队列中删除所有匹配的元素。先从队首删除，如果删除了则队首指向接下来的元素，重复这个过程，直到第一个不匹配的元素出现。接着从这个元素之后开始查找并删除。</p>
<h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p> Looper是每个线程中的MessageQueue的管家，每当发现MessageQueue中存在一条消息，就会将它取出，并传递到Handler的dispatchMessage(msg)方法中。每个线程也只会有一个Looper对象。</p>
<p>我们先看一下Looper的创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    mQueue &#x3D; new MessageQueue(quitAllowed);</span><br><span class="line">    mThread &#x3D; Thread.currentThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void prepare() &#123;</span><br><span class="line">    prepare(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() !&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">    prepare(false);</span><br><span class="line">    synchronized (Looper.class) &#123;</span><br><span class="line">        if (sMainLooper !&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper &#x3D; myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过prepare(boolean quitAllowed)在子线程中创建一个Looper，quitAllowed参数表示是否允许退出。应用启动的时候已经通过prepareMainLooper()创建了Looper了，不需要也不允许我们再次在主线程中创建。并且提供了一个getMainLooper()来获取主线程的Looper。</p>
<p>Looper最重要的方法就是loop()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Run the message queue in this thread. Be sure to call</span><br><span class="line"> * &#123;@link #quit()&#125; to end the loop.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void loop() &#123;</span><br><span class="line">&#x2F;&#x2F; &#x2F;&#x2F;获取当前Looper对象 因为是ThreadLocal中取出可以的保证拿到的是当前线程的Looper。</span><br><span class="line">    final Looper me &#x3D; myLooper();</span><br><span class="line">    if (me &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final MessageQueue queue &#x3D; me.mQueue;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Make sure the identity of this thread is that of the local process,</span><br><span class="line">    &#x2F;&#x2F; and keep track of what that identity token actually is.</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    final long ident &#x3D; Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Message msg &#x3D; queue.next(); &#x2F;&#x2F; might block</span><br><span class="line">        if (msg &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">        final Printer logging &#x3D; me.mLogging;</span><br><span class="line">        if (logging !&#x3D; null) &#123;</span><br><span class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                    msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final long slowDispatchThresholdMs &#x3D; me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">        final long traceTag &#x3D; me.mTraceTag;</span><br><span class="line">        if (traceTag !&#x3D; 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        final long start &#x3D; (slowDispatchThresholdMs &#x3D;&#x3D; 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">        final long end;</span><br><span class="line">        try &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            end &#x3D; (slowDispatchThresholdMs &#x3D;&#x3D; 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (traceTag !&#x3D; 0) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (slowDispatchThresholdMs &gt; 0) &#123;</span><br><span class="line">            final long time &#x3D; end - start;</span><br><span class="line">            if (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;</span><br><span class="line">                        + Thread.currentThread().getName() + &quot;, h&#x3D;&quot; +</span><br><span class="line">                        msg.target + &quot; cb&#x3D;&quot; + msg.callback + &quot; msg&#x3D;&quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (logging !&#x3D; null) &#123;</span><br><span class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Make sure that during the course of dispatching the</span><br><span class="line">        &#x2F;&#x2F; identity of the thread wasn&#39;t corrupted.</span><br><span class="line">        final long newIdent &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">        if (ident !&#x3D; newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                    + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                    + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                    + msg.callback + &quot; what&#x3D;&quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loop()里面获取了当前线程的Looper以及与之关联的MessageQueue。开启了一个死循环，不断地从消息队列MessageQueue拿出消息处理。那么问题就来了。</p>
<ul>
<li>Question1：这个死循环什么时候退出呢？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">queue.next()返回的为null，死循环退出。那么什么时候返回null呢？</span><br><span class="line">如果你是在子线程中自己创建的Looper，你可以调用Looper的quit()或者quitSafely()即可退出循环。二者的区别是前者直接退出，后者将消息队列中已有的消息处理完再退出。</span><br><span class="line"></span><br><span class="line">主线程的Looper呢？很抱歉，Main thread not allowed to quit.主线程的这个死循环退出了应用程序就结束了。</span><br></pre></td></tr></table></figure>

<ul>
<li>Question2：主线程的Looper开启了loop()死循环，为什么不会卡死？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.首先需要说明的一点是，正是这个死循环保证了应用程序的正常运行。</span><br><span class="line">2.Looper.loop() 当消息队列为空时，是阻塞状态。Looper空闲，线程进入阻塞，释放CPU执行权，等待唤醒。当有消息的时候就进行消息处理，然后在这个循环里面去执行的。</span><br><span class="line">3.卡死，我们一般说在主线程进行了耗时操作，可能会卡死。四大组件相关等一些操作都是通过Handler机制进行的，如果在主线程进行耗时操作，可能会导致期间其它的事件无法处理，进而卡死。</span><br></pre></td></tr></table></figure>

<ul>
<li>Question3：从消息队列MessageQueue拿出消息来交给谁处理？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由msg.target.dispatchMessage(msg)可以看出，消息交给了msg.target来处理，也就是Handler的实例。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Question4：Message会不会被回收？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息被对应的Handler处理完以后，调用msg.recycleUnchecked();相关源码见上文。</span><br></pre></td></tr></table></figure>

<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>原因：非静态内部类持有外部类的引用。</p>
<p>正确的写法：Handler写成静态的内部类，并持有外部类弱引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MyHandler myHandler&#x3D;new MyHandler(this);</span><br><span class="line">private static class MyHandler extends Handler &#123;</span><br><span class="line"></span><br><span class="line">    private WeakReference&lt;Context&gt; reference;</span><br><span class="line"></span><br><span class="line">    public MyHandler(Context context) &#123;</span><br><span class="line">        reference&#x3D;new WeakReference&lt;&gt;(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        super.handleMessage(msg);</span><br><span class="line">        AccountActivity accountActivity &#x3D; (AccountActivity) reference.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    super.onDestroy();</span><br><span class="line">    myHandler.removeCallbacksAndMessages(null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>欢迎留言交流。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/03/12/Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6Handler/" data-id="ckhtwttfu00170ouj721phf1l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Handler/" rel="tag">Handler</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" rel="tag">消息机制</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/22/%E4%BA%8C%E5%8F%89%E6%A0%91/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          二叉树
        
      </div>
    </a>
  
  
    <a href="/2019/03/08/Hexo+Github%E6%90%AD%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hexo+Github搭建你自己的博客</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Camera/" rel="tag">Camera</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Handler/" rel="tag">Handler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SignalR/" rel="tag">SignalR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jni/" rel="tag">jni</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ndk/" rel="tag">ndk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2/" rel="tag">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%A4%AB%E6%9B%BC/" rel="tag">哈夫曼</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/" rel="tag">增量更新</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" rel="tag">消息机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Camera/" style="font-size: 10px;">Camera</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Handler/" style="font-size: 10px;">Handler</a> <a href="/tags/SignalR/" style="font-size: 10px;">SignalR</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/jni/" style="font-size: 10px;">jni</a> <a href="/tags/ndk/" style="font-size: 15px;">ndk</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">博客</a> <a href="/tags/%E5%93%88%E5%A4%AB%E6%9B%BC/" style="font-size: 10px;">哈夫曼</a> <a href="/tags/%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/" style="font-size: 10px;">增量更新</a> <a href="/tags/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">消息机制</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/24/Camera%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/">Camera的一些总结</a>
          </li>
        
          <li>
            <a href="/2019/05/14/%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/">增量更新</a>
          </li>
        
          <li>
            <a href="/2019/04/27/%E6%90%9E%E5%AE%9A%E6%89%80%E6%9C%89%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9A%84Git%E6%93%8D%E4%BD%9C/">搞定所有常见的的Git操作</a>
          </li>
        
          <li>
            <a href="/2019/04/19/SignalR%E5%9C%A8Android%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/">SignalR在Android上的实践</a>
          </li>
        
          <li>
            <a href="/2019/04/15/%E9%A2%84%E7%BC%96%E8%AF%91%E5%92%8CJNI/">预编译和JNI</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>
[{"title":"Camera的一些总结","date":"2019-05-24T05:10:35.000Z","path":"2019/05/24/Camera的一些总结/","text":"前言闲谈因为最近公司在做有关摄像头的项目(人脸识别、皮肤测试)。涉及到了usb摄像头和原生的摄像头，我们usb摄像头用的UVC的库来预览的，其实用Camera来预览也是可以的。开发期间查阅了一些资料，也走了很多弯路。所以现在项目上线了，写了这篇文章，希望能够帮到在Camera迷茫的小伙伴们…… Camera和Camera2Android5.0以前，相机框架是Camera，Android5.0以后Google 引入了一套全新的相机框架 Camera2，相比之下，它更具灵活性，也增加了新的功能，如设置对焦模式、曝光模式、快门等。不过，很多文章里介绍，国内厂商对系统的定制导致对Camera2的支持不尽相同，但是我觉得还是值得一试的，下篇文章我也去探索一下Camera2(所以呢，本文总结的是Camera)。 选择Camera还是Camera2除了跟手机硬件的关系外，还有个需求是是否要适配5.0以下。Camera2是支持5.0+的。 SurfaceViewSurface我们先看一下Surface 123&#x2F;** * Handle onto a raw buffer that is being managed by the screen compositor. * Surface是用来处理屏幕显示内容合成器所管理的原始缓冲区的。原始缓冲区用来保存窗口的像素数据。 简单的说Surface对应了一块屏幕缓冲区，每个window对应一个Surface，任何View都要画在Surface的Canvas上。传统的view共享一块屏幕缓冲区。 可以认为Surface用来管理数据的。 SurfaceView123456&#x2F;** * Provides a dedicated drawing surface embedded inside of a view hierarchy. * You can control the format of this surface and, if you like, its size; the * SurfaceView takes care of placing the surface at the correct location on the * screen * SurfaceView提供了嵌入视图层级中的专用surface。你可以控制surface的格式或大小。SurfaceView负责把surface显示在屏幕的正确位置。 SurfaceView是一个View，我们再实际开发中是在布局文件里写的，但是又比较特殊。原因有二: 普通的View都是共享一个屏幕缓冲区的(Surface)，SurfaceView有单独的Surface。 普通的View只能在UI线程更新，SurfaceView没有限制。 SurfaceHolderSurfaceHolder是个接口，具体的实现在SurfaceView里。实现了很多方法，比如添加回调的方法addCallback(Callback callback)、得到Surface的画布的方法lockCanvas()等等。大概可以说SurfaceHolder用来控制Surface的尺寸、格式与像素以及监听Surface的状态的。 监听Surface的状态回调在SurfaceHolder.Callback里。我们需要在自己去监听这几个回调，实现具体的业务逻辑。 surfaceCreated(SurfaceHolder holder); 当Surface被创建后调用 surfaceChanged(SurfaceHolder holder, int format, int width, int height); 当Surface的size、format等发生变化的时候调用 surfaceDestroyed(SurfaceHolder holder); 当Surface被销毁的时候调用 权限12&lt;uses-permission android:name&#x3D;&quot;android.permission.CAMERA&quot; &#x2F;&gt;&lt;uses-feature android:name&#x3D;&quot;android.hardware.camera&quot; &#x2F;&gt; Android6.0+需要动态申请权限，这里不多说了。 Camera的实践SurfaceView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class CameraFragment extends BaseFragment implements SurfaceHolder.Callback &#123; private SurfaceView surfaceView; private SurfaceHolder surfaceHolder; private int mCameraId;&#x2F;&#x2F;摄像头id private Camera camera; public static CameraFragment newInstance() &#123; return new CameraFragment(); &#125; @Override public int getLayoutRes() &#123; return R.layout.fragment_camera; &#125; @Override public void initView(Bundle savedInstanceState) &#123; surfaceView &#x3D; findView(R.id.surfaceView); surfaceHolder&#x3D;surfaceView.getHolder(); surfaceHolder.addCallback(this); &#125; @Override public void initListener() &#123; &#125; @Override public void initData() &#123; &#125; @Override public void onResume() &#123; super.onResume(); Logger.d(&quot;gxh&quot;,&quot;onResume&quot;); &#x2F;&#x2F;startPreview(); &#125; &#x2F;** * 开启预览 *&#x2F; private void startPreview() &#123; &#x2F;&#x2F;打开摄像头 camera &#x3D; open(); try &#123; camera.setPreviewDisplay(surfaceHolder); camera.startPreview(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#x2F;** * 打开相机 * * @return *&#x2F; private Camera open() &#123; Camera camera; &#x2F;&#x2F;获取摄像头数量 int numCameras &#x3D; Camera.getNumberOfCameras(); if (numCameras &#x3D;&#x3D; 0) &#123; Logger.d(&quot;gxh&quot;,&quot;摄像头数量&quot;+numCameras); return null; &#125; int index &#x3D; 0; while (index &lt; numCameras) &#123; Camera.CameraInfo cameraInfo &#x3D; new Camera.CameraInfo(); Camera.getCameraInfo(index, cameraInfo); Logger.d(&quot;gxh&quot;,index+&quot;;&quot;+cameraInfo.facing); if (cameraInfo.facing &#x3D;&#x3D; Camera.CameraInfo.CAMERA_FACING_FRONT) &#123; break; &#125; index++; &#125; if (index &lt; numCameras) &#123; camera &#x3D; Camera.open(index); mCameraId &#x3D; index; &#125; else &#123; camera &#x3D; Camera.open(0); mCameraId &#x3D; 0; &#125; return camera; &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; Logger.d(&quot;gxh&quot;,&quot;surfaceCreated&quot;); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; Logger.d(&quot;gxh&quot;,&quot;surfaceChanged&quot;); if (holder.getSurface() &#x3D;&#x3D; null) &#123; return; &#125; startPreview(); &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; Logger.d(&quot;gxh&quot;,&quot;surfaceDestroyed&quot;); &#125;&#125; 打开与预览1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x2F;** * 开启预览 *&#x2F;private void startPreview() &#123; &#x2F;&#x2F;打开摄像头 Camera camera &#x3D; open(); try &#123; camera.setPreviewDisplay(surfaceHolder); camera.setPreviewCallback(this); camera.startPreview(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;&#x2F;** * 打开摄像头 * * @return *&#x2F;private Camera open() &#123; Camera camera; &#x2F;&#x2F;获取摄像头数量 int numCameras &#x3D; Camera.getNumberOfCameras(); if (numCameras &#x3D;&#x3D; 0) &#123; Logger.d(&quot;gxh&quot;,&quot;摄像头数量&quot;+numCameras); return null; &#125; int index &#x3D; 0; while (index &lt; numCameras) &#123; Camera.CameraInfo cameraInfo &#x3D; new Camera.CameraInfo(); Camera.getCameraInfo(index, cameraInfo); Logger.d(&quot;gxh&quot;,index+&quot;;&quot;+cameraInfo.facing); if (cameraInfo.facing &#x3D;&#x3D; Camera.CameraInfo.CAMERA_FACING_FRONT) &#123; break; &#125; index++; &#125; if (index &lt; numCameras) &#123; camera &#x3D; Camera.open(index); mCameraId &#x3D; index; &#125; else &#123; camera &#x3D; Camera.open(0); mCameraId &#x3D; 0; &#125; return camera;&#125; 没错，现在我们已经成功打开前置摄像头并预览到画面了，因为我们没有设置Camera的参数配置，所以现在画面方向、比例都有问题。这个先不着急，这里有几个问题需要谈一下： Camera.open(index) 我总有种错觉，觉得打开前置就open(1)，打开后置就open(0)。其实不是这样，index指的是numCameras中的第几个。比如魔镜系统只有一个前置摄像头(numCameras为1)，打开的话还是open(0)。 预览摄像头应该在Surface创建之后。 setPreviewDisplay应该在startPreview之前。 一定记得要release释放资源。 设置一些参数12345678910111213141516171819private void setupCameraParameters() &#123; if(parameters&#x3D;&#x3D;null)&#123; parameters &#x3D; camera.getParameters(); &#125; &#x2F;&#x2F;设置保存的图片格式 parameters.setPictureFormat(PixelFormat.JPEG); &#x2F;&#x2F;设置预览的图片格式 parameters.setPreviewFormat(ImageFormat.NV21); &#x2F;&#x2F;设置闪光灯模式 parameters.setFlashMode(Camera.Parameters.FLASH_MODE_AUTO); &#x2F;&#x2F;设置对焦模式 parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO); &#x2F;&#x2F;设置场景模式 parameters.setSceneMode(Camera.Parameters.SCENE_MODE_AUTO); camera.setParameters(parameters);&#125; 调整预览的方向图像的Sensor方向：手机Camera的图像数据都是来自于摄像头硬件的图像传感器（Image Sensor），这个Sensor被固定到手机之后是有一个默认的取景方向的，也就是手机横放Home键朝右这个方向，坐标原点位于手机横放时的左上角。 Camera的预览方向：预览方向默认情况下与图像的Sensor方向一致，所以我们看到的画面方向不正常。Google提供了setDisplayOrientation来让我们调整预览的方向。需要注意的是setDisplayOrientation只改变预览的方向，不改变拍照后图片的方向、回调的数据流方向。 Camera的拍照方向：与图像的Sensor方向一致。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#x2F;** * 设置预览方向 *&#x2F;private void setCameraDisplayOrientation() &#123; int degress&#x3D;displayOrientation(mActivity); &#x2F;&#x2F;如果确定你的应用是竖屏的，可以直接camera.setDisplayOrientation(90); camera.setDisplayOrientation(degress);&#125;private int displayOrientation(Context context) &#123; WindowManager windowManager &#x3D; (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); int rotation &#x3D; windowManager.getDefaultDisplay().getRotation(); int degrees &#x3D; 0; switch (rotation) &#123; case Surface.ROTATION_0: degrees &#x3D; 0; break; case Surface.ROTATION_90: degrees &#x3D; 90; break; case Surface.ROTATION_180: degrees &#x3D; 180; break; case Surface.ROTATION_270: degrees &#x3D; 270; break; default: degrees &#x3D; 0; break; &#125; int result &#x3D; 0; Camera.CameraInfo info &#x3D; new Camera.CameraInfo(); Camera.getCameraInfo(mCameraId, info); if (info.facing &#x3D;&#x3D; Camera.CameraInfo.CAMERA_FACING_FRONT) &#123; result &#x3D; (info.orientation + degrees) % 360; result &#x3D; (360 - result) % 360; &#125; else &#123; result &#x3D; (info.orientation - degrees + 360) % 360; &#125; Logger.d(&quot;gxh&quot;,degrees+&quot;;&quot;+result+&quot;;&quot;+info.orientation); return result;&#125; 拍照1234567891011121314151617181920camera.takePicture(null, null, new Camera.PictureCallback() &#123; @Override public void onPictureTaken(byte[] data, Camera camera) &#123; if (data &#x3D;&#x3D; null) &#123; return; &#125; String dirPath &#x3D; mActivity.getExternalCacheDir().getAbsolutePath(); final String picturePath &#x3D; dirPath + File.separator + System.currentTimeMillis() + &quot;.jpg&quot;; try &#123; FileOutputStream fileOutputStream &#x3D; new FileOutputStream(new File(picturePath)); fileOutputStream.write(data); fileOutputStream.close(); &#125; catch (Exception error) &#123; &#125; finally &#123; camera.startPreview(); &#125; &#125;&#125;); 拍照可以使用takePicture方法，拍照完要重新预览，拍照时有瞬间画面停顿。如果想不断获取图片，这个方法显然是不可取的，可以在数据流回调的方法里生成bitmap。 123456&#x2F;&#x2F;视频流的回调@Overridepublic void onPreviewFrame(byte[] data, Camera camera) &#123; Logger.d(&quot;gxh&quot;, &quot;onPreviewFrame&quot;); &#x2F;&#x2F;一般情况下，这个方法就是回调在UI线程的，所以如果想做耗时操作，需要自己开启子线程。&#125; 可以发现生成的图片方向还是不正确的，因为照片保存的方向还是由Camera的图像Sensor决定的，我们需要进行调整。可以拍完照片后进行旋转处理，也可以使用setRotation来设置角度。 12345678910111213141516171819202122232425262728293031private void setPictureOrientation() &#123; orientationEventListener &#x3D; new MyOrientationEventListener(mActivity); orientationEventListener.enable();&#125;private class MyOrientationEventListener extends OrientationEventListener &#123; public MyOrientationEventListener(Context context) &#123; super(context); &#125; @Override public void onOrientationChanged(int orientation) &#123; Logger.d(&quot;gxh&quot;, &quot;orientation:&quot; + orientation); if (orientation &#x3D;&#x3D; OrientationEventListener.ORIENTATION_UNKNOWN) return; Camera.CameraInfo info &#x3D; new Camera.CameraInfo(); Camera.getCameraInfo(mCameraId, info); orientation &#x3D; (orientation + 45) &#x2F; 90 * 90; int rotation &#x3D; 0; if (info.facing &#x3D;&#x3D; Camera.CameraInfo.CAMERA_FACING_FRONT) &#123; rotation &#x3D; (info.orientation - orientation + 360) % 360; &#125; else &#123; rotation &#x3D; (info.orientation + orientation) % 360; &#125; parameters.setRotation(rotation); camera.setParameters(parameters); &#125;&#125; 这里值得提一下的是，前置摄像头拍的照片可能和预览的左右不一致，也就是镜像。这个好像是正常的，但是根据习惯来说可能感觉怪怪的吧。所以手机自带相机一般有个设置让我们自己决定到底拍照的图片什么样子。那么自定义相机怎么办？如果我们就是不想要镜像效果呢？那只能对生成的图片修改了。 1234567Matrix matrix &#x3D; new Matrix();matrix.preRotate(360 - displayOrientation);&#x2F;&#x2F;前置摄像头生成图片 左右镜像问题matrix.postScale(-1, 1);return Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), bmp .getHeight(), matrix, true); 预览尺寸1parameters.setPreviewSize(x, y); 我们可以用上述方法设置预览尺寸，但是参数不能随便写，如果Camera不支持我们设置的参数恐怕就要崩溃了……而又为了不使预览拉伸变形，我们应该找出Camera支持的预览尺寸里最接近我们SurfaceView宽高比例的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public final class CameraPreviewUtils &#123; private static final String TAG &#x3D; CameraPreviewUtils.class.getSimpleName(); private static final int MIN_PREVIEW_PIXELS &#x3D; 640 * 480; private static final int MAX_PREVIEW_PIXELS &#x3D; 1280 * 720; &#x2F;** * 获取最好的预览尺寸 * @param parameters * @param screenResolution SurfaceView的宽高 * @return *&#x2F; public static Point getBestPreview(Camera.Parameters parameters, Point screenResolution) &#123; List&lt;Camera.Size&gt; rawSupportedSizes &#x3D; parameters.getSupportedPreviewSizes(); if (rawSupportedSizes &#x3D;&#x3D; null) &#123; Camera.Size defaultSize &#x3D; parameters.getPreviewSize(); return new Point(defaultSize.width, defaultSize.height); &#125; List&lt;Camera.Size&gt; supportedPictureSizes &#x3D; new ArrayList&lt;Camera.Size&gt;(rawSupportedSizes); Collections.sort(supportedPictureSizes, new Comparator&lt;Camera.Size&gt;() &#123; @Override public int compare(Camera.Size a, Camera.Size b) &#123; int aPixels &#x3D; a.height * a.width; int bPixels &#x3D; b.height * b.width; if (bPixels &lt; aPixels) &#123; return -1; &#125; if (bPixels &gt; aPixels) &#123; return 1; &#125; return 0; &#125; &#125;); final double screenAspectRatio &#x3D; (screenResolution.x &gt; screenResolution.y) ? ((double) screenResolution.x &#x2F; (double) screenResolution.y) : ((double) screenResolution.y &#x2F; (double) screenResolution.x); Camera.Size selectedSize &#x3D; null; double selectedMinus &#x3D; -1; double selectedPreviewSize &#x3D; 0; Iterator&lt;Camera.Size&gt; it &#x3D; supportedPictureSizes.iterator(); while (it.hasNext()) &#123; Camera.Size supportedPreviewSize &#x3D; it.next(); int realWidth &#x3D; supportedPreviewSize.width; int realHeight &#x3D; supportedPreviewSize.height; Log.d(&quot;gxh&quot;, &quot;preview size &quot; + realWidth + &quot; &quot; + realHeight); if (realWidth * realHeight &lt; MIN_PREVIEW_PIXELS) &#123; it.remove(); continue; &#125; else if (realWidth * realHeight &gt; MAX_PREVIEW_PIXELS) &#123; it.remove(); continue; &#125; else &#123; double aRatio &#x3D; (supportedPreviewSize.width &gt; supportedPreviewSize.height) ? ((double) supportedPreviewSize.width &#x2F; (double) supportedPreviewSize.height) : ((double) supportedPreviewSize.height &#x2F; (double) supportedPreviewSize.width); double minus &#x3D; Math.abs(aRatio - screenAspectRatio); boolean selectedFlag &#x3D; false; if ((selectedMinus &#x3D;&#x3D; -1 &amp;&amp; minus &lt;&#x3D; 0.25f) || (selectedMinus &gt;&#x3D; minus &amp;&amp; minus &lt;&#x3D; 0.25f)) &#123; selectedFlag &#x3D; true; &#125; if (selectedFlag) &#123; selectedMinus &#x3D; minus; selectedSize &#x3D; supportedPreviewSize; selectedPreviewSize &#x3D; realWidth * realHeight; &#125; &#125; &#125; if (selectedSize !&#x3D; null) &#123; Camera.Size preview &#x3D; selectedSize; return new Point(preview.width, preview.height); &#125; else &#123; Camera.Size defaultSize &#x3D; parameters.getPreviewSize(); return new Point(defaultSize.width, defaultSize.height); &#125; &#125;&#125; 人脸识别这个小节本来不打算写的，因为我也没打算展开写。但是还是谈几句吧…..原生的api提供了人脸识别的方法。 一种是在Camera开启人脸识别，直接回调结果。但是要注意startFaceDetection()需要在startPreview()之后。 1234567891011121314151617181920212223242526272829303132333435private void faceDetch() &#123; camera.startFaceDetection(); camera.setFaceDetectionListener(new Camera.FaceDetectionListener() &#123; @Override public void onFaceDetection(Camera.Face[] faces, Camera camera) &#123; Logger.d(&quot;gxh&quot;, &quot;onFaceDetection:&quot; + faces.length + &quot;;&quot; + Thread.currentThread().getName()); if (faces &#x3D;&#x3D; null || faces.length &#x3D;&#x3D; 0) &#123; return; &#125; Camera.Face face &#x3D; faces[0]; &#x2F;&#x2F;坐标转换 Matrix matrix &#x3D; new Matrix(); Camera.CameraInfo info &#x3D; new Camera.CameraInfo(); Camera.getCameraInfo(mCameraId, info); &#x2F;&#x2F; Need mirror for front camera. boolean mirror &#x3D; (info.facing &#x3D;&#x3D; Camera.CameraInfo.CAMERA_FACING_FRONT); matrix.setScale(mirror ? -1 : 1, 1); &#x2F;&#x2F; This is the value for android.hardware.Camera.setDisplayOrientation. matrix.postRotate(displayOrientation(mActivity)); &#x2F;&#x2F; Camera driver coordinates range from (-1000, -1000) to (1000, 1000). &#x2F;&#x2F; UI coordinates range from (0, 0) to (width, height). matrix.postScale(surfaceWidth &#x2F; 2000f, surfaceHeight &#x2F; 2000f); matrix.postTranslate(surfaceWidth &#x2F; 2f, surfaceHeight &#x2F; 2f); RectF srcRect&#x3D;new RectF(face.rect); RectF dstRect &#x3D;new RectF(0f, 0f, 0f, 0f); matrix.mapRect(dstRect,srcRect); faceView.drawFace(dstRect); &#125; &#125;);&#125; 另一种则是直接检测Bitmap。所以可以直接检测本地图片，也可以将Camera回调中onPreviewFrame(byte[] data, Camera camera)的data转为bitmap来检测。 123FaceDetector faceDetector &#x3D; new FaceDetector(bm.getWidth(), bm.getHeight(), MAX_FACE_NUM);FaceDetector.Face[] faces &#x3D; new FaceDetector.Face[MAX_FACE_NUM];realFaceNum &#x3D; faceDetector.findFaces(bm, faces); 不管是原生api的哪种方法，看起来效果并不是特别的好，要是商用的话恐怕不能满足。所以，可能要使用诸如虹软、百度、中科等的sdk了(绝对不是打广告！)。具体不多少了，只是基本上都是涉及到了onPreviewFrame(byte[] data, Camera camera)这个回调中的data数据。 释放1234567891011121314151617private void stopPreview() &#123; if (camera !&#x3D; null) &#123; try &#123; camera.setErrorCallback(null); camera.setPreviewCallback(null); camera.stopFaceDetection(); camera.stopPreview(); &#125; catch (RuntimeException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; camera.release(); camera &#x3D; null; &#125; &#125;&#125; Camera与子线程我们知道，Camera的打开是耗时的，我们可以放在子线程里。那么我们既然要在onPreviewFrame(byte[] data, Camera camera)回调中进行人脸识别比对等等，还要自己再开子线程，我们想这个回调就是子线程回调的要怎么办？ 假如我们在子线程打开的Camera，那么onPreviewFrame(byte[] data, Camera camera)就会在子线程？恐怕想得美。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class HandlerThreadActivity2 extends Activity implements Callback &#123; static final String TAG &#x3D; &quot;jason&quot;; Camera mCamera; SurfaceView surfaceView; SurfaceHolder surfaceHolder; byte[] buffers; HandlerThread mHandlerThread &#x3D; new HandlerThread(&quot;my_handlerthread&quot;); Handler subHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_handler_thread2); surfaceView &#x3D; (SurfaceView) findViewById(R.id.surface_view); surfaceHolder &#x3D; surfaceView.getHolder(); surfaceHolder.addCallback(this); &#125; class MyTask implements Runnable, PreviewCallback&#123; @Override public void run() &#123; &#x2F;&#x2F;打开相机 &#x2F;&#x2F;子线程中打开 Log.d(&quot;jason&quot;, Thread.currentThread().getName() + &quot;_open&quot;); mCamera &#x3D; Camera.open(CameraInfo.CAMERA_FACING_BACK); try &#123; mCamera.setPreviewDisplay(surfaceHolder); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Camera.Parameters parameters &#x3D; mCamera.getParameters(); &#x2F;&#x2F;设置相机参数 parameters.setPreviewSize(480, 320); &#x2F;&#x2F;预览画面宽高 mCamera.setParameters(parameters); &#x2F;&#x2F;获取预览图像数据 buffers &#x3D; new byte[480 * 320 * 4]; mCamera.addCallbackBuffer(buffers); mCamera.setPreviewCallbackWithBuffer(this); mCamera.startPreview(); Log.d(TAG, Thread.currentThread().getName()+ &quot;_run&quot;); &#125; @Override public void onPreviewFrame(byte[] data, Camera camera) &#123; if(mCamera !&#x3D; null)&#123; mCamera.addCallbackBuffer(buffers); &#x2F;&#x2F;编码 Log.d(TAG, Thread.currentThread().getName()+ &quot;_onPreviewFrame&quot;); &#125; &#125; &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; mHandlerThread.start(); subHandler &#x3D; new Handler(mHandlerThread.getLooper()); subHandler.post(new MyTask()); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; &#125;&#125; Camera维护了一个EventHandler。 Handler.handleMessage的执行一定在它的Looper所在线程中。 onPreviewFrame的执行在Camera所持有的Looper所在线程中执行。 结束语 参考文章 Android中的Surface和SurfaceView Android开发实践：掌握Camera的预览方向和拍照方向 文章同步发布在黑白了落夜","link":"","tags":[{"name":"Android","slug":"Android","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/Android/"},{"name":"Camera","slug":"Camera","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/Camera/"}]},{"title":"增量更新","date":"2019-05-14T02:28:00.000Z","path":"2019/05/14/增量更新/","text":"前言增量更新的主要目的是省流量。关于在哪个页面更新、到底提示不提示更新、是否强制更新等等这都不是增量更新的重点，这些根据具体需求就好了。增量更新主要就是用更少的流量去更新。 增量更新主要涉及两个操作：差分、合并。合并指的是当前版本与所对应的差分包进行合并，这个操作在客户端完成。差分指的是新版本与之前旧版本所产生差分包，这个操作在服务端完成。后台应该有上传apk的功能，比如上传3.0版本的apk，那么上传完就应该生成各种差分包，比如与2.0版本apk的差分包、与1.0版本apk的差分包。 新旧版本重复部分越多，差分包越小；重复部分越少，差分包越大。 我们这里增量更新使用BsDiff开源项目，这个项目本来又依赖bzip。官网 服务器端编译BsDiff开源项目 新建项目bsdiff，将源码中.c文件、.cpp文件、.h文件复制进该项目(\\bsdiff\\bsdiff) 源文件–&gt;添加–&gt;现有项 (选择.c和.cpp文件) 头文件–&gt;添加–&gt;现有项 (选择.h) 删掉bsdiff.cpp文件 编译报错 1234567891011121314会提示使用了过时的方法以及不安全。在bsdiff.cpp里加入下面的宏定义。#define _CRT_SECURE_NO_WARNINGS#define _CRT_NONSTDC_NO_DEPRECATE上面在这个文件写宏定义，如果好几个文件都用过，写起来就麻烦了。可以用下面方法：右键项目--&gt;属性--&gt;配置属性--&gt;c&#x2F;c++ --&gt;命令行--&gt;其它选项输入下面这句-D _CRT_SECURE_NO_WARNINGS -D _CRT_NONSTDC_NO_DEPRECATE接着编译。下面报错。C4703 使用了可能未初始化的本地指针变量“old” 等等。解决方法：右键项目--&gt;属性--&gt;配置属性--&gt;c&#x2F;c++ --&gt;常规--&gt;SDL检查 否 生成动态库.dll的一些配置。(不再重复介绍，可见前面博客) bsdiff.cpp的main函数我们就可以自己使用了，换个名字，改成bsdiff_main 然后就是写Java层代码，写JNI，生成.dll库，Java层调用。步骤可见前面博客，代码见下文。主要代码如下： 12345678910111213141516171819202122JNIEXPORT void JNICALL Java_cn_gxh_update_server_BsDiff_diff(JNIEnv *env, jclass jcls, jstring oldfile_jstr, jstring newfile_jstr, jstring patchfile_jstr) &#123; int argc &#x3D; 4; char* oldfile &#x3D; (char*)env-&gt;GetStringUTFChars(oldfile_jstr, NULL); char* newfile &#x3D; (char*)env-&gt;GetStringUTFChars(newfile_jstr, NULL); char* patchfile &#x3D; (char*)env-&gt;GetStringUTFChars(patchfile_jstr, NULL); &#x2F;&#x2F;参数,第一个参数无效 char *argv[4]; argv[0] &#x3D; &quot;bsdiff&quot;; &#x2F;&#x2F;strcpy(argv[1],oldfile); &#x2F;&#x2F;strcpy(argv[2], newfile); &#x2F;&#x2F;strcpy(argv[3], patchfile); argv[1] &#x3D; oldfile; argv[2] &#x3D; newfile; argv[3] &#x3D; patchfile; bsdiff_main(argc, argv); env-&gt;ReleaseStringUTFChars(oldfile_jstr, oldfile); env-&gt;ReleaseStringUTFChars(newfile_jstr, newfile); env-&gt;ReleaseStringUTFChars(patchfile_jstr, patchfile);&#125; Windows服务器下产生差分包上面我们已经生成了bsdiff.dll文件。下面是java层对用的代码： 1234567891011package cn.gxh.update.server;public class BsDiff &#123; public native static void diff(String oldfile ,String newfile,String patchfile); static&#123; System.loadLibrary(&quot;bsdiff&quot;); &#125;&#125; 调用生成差分包: 123&#x2F;&#x2F;得到差分包BsDiff.diff(ConstantsWin.OLD_APK_PATH, ConstantsWin.NEW_APK_PATH, ConstantsWin.PATCH_PATH); 客户端客户端的主要工作是：下载、合并。下载的过程我们就不提了，反正下载的是.patch差分包。这里我们主要介绍是怎么合并的。 我们主要用到了bsdiff开源项目的bspatch.c文件，这里面有个main方法是来做合并的。(所以用的时候还是改革名字，改成bspatch_main吧) 这里也是NDK的开发流程，可以参考之前的博客，这里不多说了。贴一下主要的代码。值得一提的是，bspatch.c使用了bzip2的代码，所以需要把bzip2复制到jni目录下，改一下bspatch.c的相关文件的引入。 12345678910&#x2F;&#x2F;java层代码：package cn.gxh.update.util;public class BsPatch &#123; public native static void patch(String oldfile,String newfile,String patchfile); static&#123; System.loadLibrary(&quot;bspatch&quot;); &#125;&#125; 1234567891011121314151617181920&#x2F;&#x2F;这里编译的bspatch.c文件，合并的代码直接在这个文件里写的。JNIEXPORT void JNICALL Java_cn_gxh_update_util_BsPatch_patch (JNIEnv *env, jclass jcls, jstring oldfile_jstr, jstring newfile_jstr, jstring patchfile_jstr)&#123; int argc &#x3D; 4; char* oldfile&#x3D;(char*)(*env)-&gt;GetStringUTFChars(env,oldfile_jstr,NULL); char* newfile &#x3D; (char*)(*env)-&gt;GetStringUTFChars(env,newfile_jstr, NULL); char* patchfile &#x3D; (char*)(*env)-&gt;GetStringUTFChars(env,patchfile_jstr, NULL); &#x2F;&#x2F;参数,第一个参数无效 char *argv[4]; argv[0] &#x3D; &quot;bspatch&quot;; argv[1] &#x3D; oldfile; argv[2] &#x3D; newfile; argv[3] &#x3D; patchfile; bspatch_main(argc,argv); (*env)-&gt;ReleaseStringUTFChars(env,oldfile_jstr, oldfile); (*env)-&gt;ReleaseStringUTFChars(env,newfile_jstr, newfile); (*env)-&gt;ReleaseStringUTFChars(env,patchfile_jstr, patchfile);&#125; 说明所有资料均可下载 若没有积分下载，可评论留下邮箱。。","link":"","tags":[{"name":"ndk","slug":"ndk","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/ndk/"},{"name":"增量更新","slug":"增量更新","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/"}]},{"title":"搞定所有常见的的Git操作","date":"2019-04-27T09:15:30.000Z","path":"2019/04/27/搞定所有常见的的Git操作/","text":"Git工作区 Git仓库 最终确定的文件保存到仓库，成为一个新的版本，并且对他人可见。 暂存区(索引) 暂存已经修改的文件最后统一提交到git仓库中。 工作区 添加、编辑、修改文件等工作。 Git操作流程 初始化一个新的Git仓库 1234567&#x2F;&#x2F;创建文件夹testmkdir test&#x2F;&#x2F;在文件夹内初始化Git仓库cd testgit init &#x2F;&#x2F;执行此命令后，会生成.git隐藏文件夹，用来存储所有git信息 向仓库提交文件 12&#x2F;&#x2F;我们先在test里写个aa文件touch aa.txt 我们用 git status查看一下状态，文件是红色的，说明该文件还在工作区。 12345&#x2F;&#x2F;将工作区的文件提交到暂存区git add . &#x2F;&#x2F;将所有文件夹添加到本地暂存区git add 文件 &#x2F;&#x2F;将指定文件添加到本地暂存区 此时查看状态，文件为绿色，表示已经在暂存区了。 12&#x2F;&#x2F;将本地暂存区代码提交到当前分支 git commit -m &quot;添加代码&quot; 提交到当前分支之后，再查看状态，已经是nothing to commit了，查看提交记录，可以看到有一次提交的信息。 修改文件 不管是我们修改还是删除添加文件，只要我们进行了新的操作，想提交到当前分支的话，都要经过上面那一系列操作，也就是先添加到暂存区，再提交到分支。 提交到远程仓库 上面所有的操作都是在本地，那么怎么把本地代码同步到远程仓库呢？先commit到本地分支后，再push到远程。 1234git push origin 远程分支名&#x2F;&#x2F;如果远程仓库没有这个分支，会自动创建的。 这里我们是在本地先建的仓库，再提交的。实际中可能是先把远程仓库的代码clone到本地。 12&#x2F;&#x2F;在你想复制到的目录下执行clone操作git clone 仓库地址 其它命令 git remote -v 查看指向的远程仓库的地址 git branch -a 查看分支，红色的是远程分支，带星号的是当前的本地分支。 撤消 git commit –amend 这个命令操作会让你重新修改上一次的提交附带信息，并且将目前暂存区的代码也提交，并且会覆盖上一次的提交(上一次的提交记录消失)。这个命令我感觉提交信息写错了可以用。 暂存区的文件撤回 1git reset HEAD 文件名带后缀 撤回工作区的文件 就是你改了某个文件，觉得不多，下面命令可以让你获取到上一次commit的这个文件，直接覆盖掉当前这个文件。注意的是这个文件得是在工作区。提交到了暂存区是不行的。 1git checkout -- 文件名带后缀 commit之后的撤回 1234567891011121314151617181920212223242526272829303132333435下面以撤回一次为例。方式1： git reset --soft HEAD~这种方式本质上是撤销了上一次 git commit 命令，上一次commit的内容还在暂存区。如果撤回到某个提交: git reset --soft 路径通俗点来说：之前工作区的代码：还在之前暂存区的代码：还在暂存区已提交的代码：该路径(提交对象)下的代码就是最新的代码，包括之后的代码。方式2： git reset --mixed HEAD~它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。如果撤回到某个提交: git reset --mixed 路径通俗点来说：之前工作区的代码：还在之前暂存区的代码：变成工作的代码已提交的代码：该路径(提交对象)下的代码就是最新的代码，包括之后的代码。方式3：git reset --hard HEAD~这个命令是非常危险的。撤销了最后的提交、git add 和 git commit 命令以及工作目录中的所有工作。如果撤回到某个提交: git reset --hard 路径通俗点来说：之前工作区的代码：还在之前暂存区的代码：消失已提交的代码：该路径(提交对象)之后的代码消失 多个分支的管理 查看本地所有分支(当前分支绿色且带星号) 1git branch 当前我们只有一个master分支。 本地新建分支branch1 12git branch branch1 这个命令是在当前所在的提交对象上创建一个指针，也就是这个分支指向最后一次commit。所有此时有两个分支指向最后一次提交对象。但是当前分支不变，并没有切到这个新分支上。 也就是说，我们此时继续在当前分支master修改文件再commit，刚才那个branch1分支还是依然指向刚才那次提交。 切到新分支 12git checkout branch1 这时我们已经切到新分支了，可以在上面开发，再commit。 合并 这个问题就比较复杂一点了，我们切回master分支重新操作。这里我们先写一个cc.txt，内容是：上线啦。commit到当前分支。 在当前，假如要开发新功能，所以要新建分支branch2来开发，在该分支下新建dd.txt。但是开发过程中我们上线的版本出了bug，所以要切回到master。要注意的是一定要把branch2写的代码commit，不然会出现不可预期的结果。 好了，切回到master后，开分支q12来处理bug。 这时候我们改完了bug，要合并到master分支去了。先切回master再合并。 由于当前 master 分支所指向的提交是你当前提交（有关 q12 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧。 此时master被快进到q12，和q12一起都指向了b5d31f1这个提交对象。这时候我们就不再需要q12了，可以删了这个分支。 1git branch -d q12 如果branch2分支开发完了，我们也要合并到master。 这和之前合并q12分支的时候看起来有一点不一样。 在这种情况下，开发历史从一个更早的地方开始分叉开来（ec06f8e）。 因为，master 分支所在提交并不是 branch2 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（b5d31f1 和 68ce7ac）以及这两个分支的共同祖先（ec06f8e），做一个简单的三方合并。合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 常见问题 fatal: No configured push destination. 没有设置远程仓库地址，所有push的时候出问题。 1git remote add origin https:&#x2F;&#x2F;github.com&#x2F;gxh-apologize&#x2F;test.git 需要说明的是，这个origin是远程仓库的默认名字，没有特殊的含义，尽管真实仓库名不是这个，但是我们没有特别指定的话，git默认就是origin。 fatal: The current branch master has no upstream branch. 本地的分支没有和远程的分支关联起来，很可能只是执行了git push,git不知道push的目标分支。 12git push --set-upstream origin master HEAD是什么？ HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 说明本文的初衷是简单快捷了解使用git，所以可能存在一些不严谨表述。如果需要更详细了解git，还请翻阅","link":"","tags":[{"name":"Android","slug":"Android","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/Android/"},{"name":"Git","slug":"Git","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/Git/"}]},{"title":"SignalR在Android上的实践","date":"2019-04-19T03:22:30.000Z","path":"2019/04/19/SignalR在Android上的实践/","text":"闲言因为我们后台是 .net，所以要求使用SignalR来实现推送。因为网上资料也不多，也走了很多弯路。现在记录一下，希望可以帮到更多的人。 首先要确认后台用的是 asp.net 还是 asp.net core ，这两个的SignalR还是有区别的，我们Android用的库也不一样，我认为是不兼容的。 如果使用的是 asp.net，这里有个库可以使用。java-client 但是不再维护了。也可以试试这个，但是也不维护了。 如果后台使用的是 asp.net core ，那就接着看吧。 实践这里我们说的后台是 asp.net core，我们该怎么办。首先看一下官网的一些信息。 另外，还有github上的地址 官网上给出了使用的步骤： 添加依赖 123implementation &#39;com.microsoft.signalr:signalr:1.0.0&#39;&#x2F;&#x2F;下面这个是日志输出，上面这个库用到了这个implementation group: &#39;org.slf4j&#39;, name: &#39;slf4j-android&#39;, version: &#39;1.7.7&#39; 代码 1234567891011121314151617181920212223242526272829303132333435 HubConnection hubConnection; public void signalr() &#123; &#x2F;&#x2F;创建HubConnection hubConnection &#x3D; HubConnectionBuilder.create(url) .build(); &#x2F;&#x2F;客户端需要在hubConnection对象执行start()方法之前对服务端需要调用的方法进行注册 &#x2F;&#x2F;这里的message是服务端发给我们的信息 hubConnection.on(&quot;SendAsync&quot;, (message) -&gt; &#123; Logger.d(&quot;gxh&quot;,message+&quot;#haha&quot;); &#125;, String.class); new HubConnectionTask().execute(hubConnection); &#125; class HubConnectionTask extends AsyncTask&lt;HubConnection, Void, Void&gt; &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); &#125; @Override protected Void doInBackground(HubConnection... hubConnections) &#123; HubConnection hubConnection &#x3D; hubConnections[0]; &#x2F;&#x2F;开始连接并等待连接成功 hubConnection.start().blockingAwait(); Logger.d(&quot;gxh&quot;,hubConnection.getConnectionState().toString()); return null; &#125; &#125; &#x2F;&#x2F;客户端调用服务端的方法 ，这里的方法名和参数要参考服务端写的，要一致。hubConnection.send(&quot;Send&quot;, &quot;hhhhhhhhh&quot;); 按照上面的步骤，你看下日志，如果连接成功了，那ok了。不用接着看了。但是我还是失败了(可以连接到该库的测试地址上，但是连不上我们服务器的地址上)。 1234567891011121314151617181920212204-18 14:09:14.827 3655-3724&#x2F;cn.gxh.view E&#x2F;OkHttpWebSocketWrapper: WebSocket closed from an error: Expected &#39;Connection&#39; header value &#39;Upgrade&#39; but was &#39;null&#39;.04-18 14:09:14.828 3655-3724&#x2F;cn.gxh.view I&#x2F;WebSocketTransport: WebSocket connection stopping with code null and reason &#39;Expected &#39;Connection&#39; header value &#39;Upgrade&#39; but was &#39;null&#39;&#39;.04-18 14:09:14.828 3655-3724&#x2F;cn.gxh.view E&#x2F;c*.m*.s*.HubConnection: HubConnection disconnected with an error Expected &#39;Connection&#39; header value &#39;Upgrade&#39; but was &#39;null&#39;.--------- beginning of crash04-18 14:09:14.831 3655-3724&#x2F;cn.gxh.view E&#x2F;AndroidRuntime: FATAL EXCEPTION: OkHttp DispatcherProcess: cn.gxh.view, PID: 3655java.lang.NullPointerException: Attempt to invoke virtual method &#39;void com.microsoft.signalr.HubConnection$ConnectionState.cancelOutstandingInvocations(java.lang.Exception)&#39; on a null object referenceat com.microsoft.signalr.HubConnection.stopConnection(HubConnection.java:431)at com.microsoft.signalr.HubConnection.lambda$start$6$HubConnection(HubConnection.java:301)at com.microsoft.signalr.HubConnection$$Lambda$19.invoke(Unknown Source)at com.microsoft.signalr.WebSocketTransport.onClose(WebSocketTransport.java:93)at com.microsoft.signalr.WebSocketTransport.lambda$start$1$WebSocketTransport(WebSocketTransport.java:56)at com.microsoft.signalr.WebSocketTransport$$Lambda$1.invoke(Unknown Source)at com.microsoft.signalr.OkHttpWebSocketWrapper$SignalRWebSocketListener.onFailure(OkHttpWebSocketWrapper.java:98)at okhttp3.internal.ws.RealWebSocket.failWebSocket(RealWebSocket.java:570)at okhttp3.internal.ws.RealWebSocket$2.onResponse(RealWebSocket.java:197)at okhttp3.RealCall$AsyncCall.execute(RealCall.java:153)at okhttp3.internal.NamedRunnable.run(NamedRunnable.java:32)at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1133)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:607)at java.lang.Thread.run(Thread.java:761) 按照该库维护人员的建议：upgrade to the 3.0.0-preview3-19153-02 version. 1implementation &#39;com.microsoft.signalr:signalr:3.0.0-preview3-19153-02&#39; 因为这个版本 can set the transport to LongPolling 123hubConnection &#x3D; HubConnectionBuilder.create(url) .withTransport(TransportEnum.LONG_POLLING) .build(); 其它无变化，至此，连接成功。 12304-19 11:15:53.986 7924-7954&#x2F;cn.gxh.view I&#x2F;c*.m*.s*.HubConnection: HubConnection started.04-19 11:15:53.988 7924-7951&#x2F;cn.gxh.view E&#x2F;gxh: CONNECTED04-19 11:15:54.048 7924-7960&#x2F;cn.gxh.view E&#x2F;gxh: User tom: hi Baby#haha 最后，还有一点要说的，按照官网上写的： 1The Java client is available in ASP.NET Core 2.2 and later. 这个库是在 asp.net core 2.2以及以后才可以用的，但是吧，该库的维护人员说2.1应该也可以用。所以，尽管试试吧。","link":"","tags":[{"name":"SignalR","slug":"SignalR","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/SignalR/"},{"name":"Android","slug":"Android","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/Android/"}]},{"title":"预编译和JNI","date":"2019-04-15T07:29:00.000Z","path":"2019/04/15/预编译和JNI/","text":"预编译C语言执行的流程： 编译：形成目标代码（.obj） 连接：将目标代码与C函数库连接合并，形成最终的可执行文件 执行 预编译：为编译做准备工作，完成代码文本的替换工作。 头文件只是告诉编译器有这种函数，连接器负责找到函数的实现。 define指令： 定义标识 12345678910111213141516171819202122232425262728293031323334353637#ifdef _cplusplus &#x2F;&#x2F;标识支持C++语法也可以通过define防止文件重复引入举个栗子：头文件A.h和B.h相互引用，A.h：#ifndef AH &#x2F;&#x2F;如果没有定义AH#define AH#include &lt;B.h&gt;void printA();#endifB.h#ifndef BH#define BH#include &lt;A.h&gt;void printB();#endif其实新的编译器可以使用另一种方法，也能保证头文件执行一次pragma一般只用在头文件，整个头文件只包含一次A.h#pragma once#include &lt;B.h&gt;void printA();B.h#pragma once#include &lt;A.h&gt;void printB(); 定义常数 1#define MAX 100 这个和全局变量是不一样，这个没有类型，只是个替换。这么写便于阅读和修改。 定义宏函数 123456789101112131415161718192021222324#define jni(NAME) dn_com_jni_##NAME();&#x2F;&#x2F;日志输出&#x2F;&#x2F;#define LOG(FORMAT,...) printf(FORMAT,__VA_ARGS__);&#x2F;&#x2F;#define LOG_I(FORMAT,...) printf(&quot;INFO:&quot;); printf(FORMAT,__VA_ARGS__);&#x2F;&#x2F;升级版#define LOG(LEVEL,FORMAT,...) printf(LEVEL);printf(##FORMAT,__VA_ARGS__);#define LOG_I(FORMAT,...) LOG(&quot;INFO:&quot;,FORMAT,__VA_ARGS__);#define LOG_E(FORMAT,...) LOG(&quot;ERROR:&quot;,FORMAT,__VA_ARGS__);void dn_com_jni_write() &#123; printf(&quot;dn_com_jni_write&quot;);&#125;void main() &#123; jni(write);&#x2F;&#x2F; LOG(&quot;%s\\n&quot;,&quot;haha&quot;);&#x2F;&#x2F; LOG(&quot;%s,%s,%s\\n&quot;,&quot;hh&quot;,&quot;haha&quot;,&quot;dudu&quot;);&#x2F;&#x2F; LOG_I(&quot;%s\\n&quot;,&quot;en&quot;); system(&quot;pause&quot;);&#125; JNIJNI简介JNI java native interface java本地开发接口。JNI是一个协议，通过这个协议，可以实现java代码调用外部的c/c++代码，外部的c/c++代码也可以调用java代码。 为什么用JNI： 扩展了java虚拟机的能力 本地代码效率更高 复用c代码（人脸识别，ffmpeg） c语言反编译比java难 每个native函数都至少有两个参数。 参数一：JNIEnv* env JNIEnv在C中其实是结构体指针，代表java运行环境，调用java中的代码env在C中其实就是二级指针JNIEnv在C++ 中是一个结构体别名，那么env在C++中是一个结构体指针。 参数二：当native方法为静态方法时，jclass代表native方法所属类的class对象。当native方法为非静态方法时，jobject代表native方法所属的对象。 Java调C 编写native方法 1234567891011121314151617&#x2F;&#x2F;新建Java工程，新建JniTest类package cn.gxh;public class JniTest &#123; public native String getStringFromC(); &#x2F;** * @param args *&#x2F; public static void main(String[] args) &#123; &#x2F;&#x2F; TODO Auto-generated method stub &#125;&#125; javah命令，生成.h头文件 12进入Java工程src目录下，javah cn.gxh.JniTest此时会生成头文件 1234567891011121314151617181920212223242526272829&#x2F;* DO NOT EDIT THIS FILE - it is machine generated *&#x2F;#include &lt;jni.h&gt;&#x2F;* Header for class cn_gxh_JniTest *&#x2F;#ifndef _Included_cn_gxh_JniTest#define _Included_cn_gxh_JniTest#ifdef __cplusplusextern &quot;C&quot; &#123;#endif&#x2F;* * Class: cn_gxh_JniTest * Method: getStringFromC * Signature: ()Ljava&#x2F;lang&#x2F;String; *&#x2F;JNIEXPORT jstring JNICALL Java_cn_gxh_JniTest_getStringFromC (JNIEnv *, jclass);&#x2F;* * Class: cn_gxh_JniTest * Method: getStringFromC2 * Signature: ()Ljava&#x2F;lang&#x2F;String; *&#x2F;JNIEXPORT jstring JNICALL Java_cn_gxh_JniTest_getStringFromC2 (JNIEnv *, jobject);#ifdef __cplusplus&#125;#endif#endif 复制.h头文件到cpp工程 复制jdk下面的jni.h和jni_md.h文件到cpp工程中 1234确保这几个头文件复制到了项目里如果无法打开这几个头文件项目-&gt;属性-&gt;C&#x2F;C++-&gt;常规-&gt;附加包含目录-&gt;编辑中，把此路径添加上 实现.h头文件中声明的函数 123456789101112131415#include &lt;stdio.h&gt;#include &quot;cn_gxh_JniTest.h&quot;&#x2F;&#x2F;函数实现JNIEXPORT jstring JNICALL Java_cn_gxh_JniTest_getStringFromC(JNIEnv *env, jclass jcls)&#123; return (*env)-&gt;NewStringUTF(env,&quot;C String&quot;);&#125;JNIEXPORT jstring JNICALL Java_cn_gxh_JniTest_getStringFromC2(JNIEnv *env, jobject jobj) &#123; return (*env)-&gt;NewStringUTF(env, &quot;C String 2&quot;);&#125; 生成dll文件 123456项目-&gt;属性-&gt;配置管理器-&gt;活动解决方案平台常规-&gt;配置类型-&gt;动态库&#x2F;&#x2F;生成dll文件生成-&gt;生成解决方案 配置dll文件所在目录到环境变量 或者放到工程根目录下 重启Eclipse 12345678910111213141516171819202122package cn.gxh;public class JniTest &#123; public native static String getStringFromC(); public native String getStringFromC2(); &#x2F;** * @param args *&#x2F; public static void main(String[] args) &#123; System.out.print(getStringFromC()); JniTest jniTest&#x3D;new JniTest(); System.out.print(jniTest.getStringFromC2()); &#125; static&#123; System.loadLibrary(&quot;Project1&quot;); &#125;&#125; C访问Java 访问非静态属性 12345678910111213141516171819202122&#x2F;&#x2F;访问java的非静态属性 public String key&#x3D;&quot;liyifeng&quot;;JNIEXPORT void JNICALL Java_cn_gxh_JniTest_accessField(JNIEnv *env, jobject jobj)&#123; &#x2F;&#x2F;得到jclass jclass cls&#x3D;(*env)-&gt;GetObjectClass(env,jobj); &#x2F;&#x2F;参数三：属性名 参数四:签名 jfieldID fid&#x3D;(*env)-&gt;GetFieldID(env, cls, &quot;key&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); &#x2F;&#x2F;获取属性key的值 jstring jstr&#x3D;(*env)-&gt;GetObjectField(env,jobj,fid); &#x2F;&#x2F;jstring转c的字符串 char* c_str&#x3D;(*env)-&gt;GetStringUTFChars(env,jstr,JNI_FALSE); char text[20] &#x3D; &quot;who is &quot;; strcat(text,c_str); &#x2F;&#x2F;c字符串转jstring jstring new_str&#x3D;(*env)-&gt;NewStringUTF(env,text); &#x2F;&#x2F;修改key (*env)-&gt;SetObjectField(env,jobj,fid, new_str);&#125; 访问静态属性 123456789101112&#x2F;&#x2F;访问静态属性 public static int count&#x3D;7;JNIEXPORT void JNICALL Java_cn_gxh_JniTest_accessStaticField(JNIEnv *env, jobject jobj)&#123; &#x2F;&#x2F;得到jclass jclass cls &#x3D; (*env)-&gt;GetObjectClass(env, jobj); jfieldID fid &#x3D; (*env)-&gt;GetStaticFieldID(env, cls, &quot;count&quot;, &quot;I&quot;); jint j_count &#x3D; (*env)-&gt;GetStaticIntField(env, cls, fid); j_count++; (*env)-&gt;SetStaticIntField(env,cls,fid,j_count);&#125; 访问非静态方法 1234567891011121314151617181920public int genRandomInt(int max)&#123; return new Random().nextInt(max);&#125; public native void accessMethod();&#x2F;&#x2F;访问非静态方法JNIEXPORT void JNICALL Java_cn_gxh_JniTest_accessMethod(JNIEnv *env, jobject jobj)&#123; &#x2F;&#x2F;得到jclass jclass cls &#x3D; (*env)-&gt;GetObjectClass(env, jobj); jmethodID mid&#x3D;(*env)-&gt;GetMethodID(env,cls,&quot;genRandomInt&quot;,&quot;(I)I&quot;); &#x2F;&#x2F;调用 jint j_random&#x3D;(*env)-&gt;CallIntMethod(env,jobj,mid,200); printf(&quot;random：%ld&quot;,j_random);&#125; 访问静态方法 12345678910111213141516171819public static String getUUID()&#123; return UUID.randomUUID().toString();&#125;public native void accessStaticMethod();&#x2F;&#x2F;访问静态方法JNIEXPORT void JNICALL Java_cn_gxh_JniTest_accessStaticMethod(JNIEnv *env, jobject jobj)&#123; &#x2F;&#x2F;得到jclass jclass cls &#x3D; (*env)-&gt;GetObjectClass(env, jobj); jmethodID mid &#x3D; (*env)-&gt;GetStaticMethodID(env, cls, &quot;getUUID&quot;, &quot;()Ljava&#x2F;lang&#x2F;String;&quot;); &#x2F;&#x2F;调用 jstring j_str &#x3D; (*env)-&gt;CallStaticObjectMethod(env, cls, mid); char* c_str &#x3D; (*env)-&gt;GetStringUTFChars(env, j_str, JNI_FALSE); printf(&quot;uuid：%s&quot;, c_str);&#125; 访问构造方法 1234567891011121314151617这里我们访问java中的Date类，实例化它的对象，调用它的getTime()方法。&#x2F;&#x2F;访问构造方法JNIEXPORT void JNICALL Java_cn_gxh_JniTest_accessConstructor(JNIEnv *env, jobject jobj)&#123; &#x2F;&#x2F;得到jclass jclass cls &#x3D; (*env)-&gt;FindClass(env, &quot;java&#x2F;util&#x2F;Date&quot;); jmethodID constructor_mid&#x3D;(*env)-&gt;GetMethodID(env,cls,&quot;&lt;init&gt;&quot;,&quot;()V&quot;); &#x2F;&#x2F;实例化对象 jobject date_obj&#x3D;(*env)-&gt;NewObject(env,cls,constructor_mid); &#x2F;&#x2F;调用getTime方法 jmethodID mid&#x3D;(*env)-&gt;GetMethodID(env,cls,&quot;getTime&quot;,&quot;()J&quot;); &#x2F;&#x2F;调用 这个方法返回值xxx 就CallxxxMethod jlong time&#x3D;(*env)-&gt;CallLongMethod(env,date_obj,mid); printf(&quot;\\ntime:%ld&quot;,time);&#125; 注意事项 我们为了在java中触发，每个例子都写了native方法。实际中不一定需要。 C访问java这几个例子中静态非静态指的是要访问的属性、方法。并不是native方法是不是静态的。 这几个例子的native方法都是非静态的。由参数(JNIEnv *env, jobject jobj)可以看出。 假如native方法是静态的，参数(JNIEnv *env, jclass cls) 属性的签名可以参考下表（也可以用命令）。方法的签名得使用命令了。 Java类型 签名 boolean Z byte B char C short S int I long J float F double D void V Array Object L开头，然后以/分隔它的完整类名，最后加分号。比如String的签名为Ljava/lang/String; 1javap -s -p 完整类名(比如: java.util.Date) C代码中文返回乱码 12345678910111213141516171819char* c_str &#x3D; &quot;李易峰&quot;;&#x2F;&#x2F;c--&gt;jstringreturn (*env)-&gt;NewStringUTF(env,c_str);上面这种写法会乱码。正确写法如下：jclass cls&#x3D;(*env)-&gt;FindClass(env,&quot;java&#x2F;lang&#x2F;String&quot;);jmethodID constructor_mid&#x3D;(*env)-&gt;GetMethodID(env,cls,&quot;&lt;init&gt;&quot;,&quot;([BLjava&#x2F;lang&#x2F;String;)V&quot;);char* c_str &#x3D; &quot;李易峰&quot;;&#x2F;&#x2F;char c_str[] &#x3D; &quot;李易峰&quot;;jbyteArray byteArray&#x3D;(*env)-&gt;NewByteArray(env,strlen(c_str));&#x2F;&#x2F;byte数组赋值(*env)-&gt;SetByteArrayRegion(env,byteArray,0,strlen(c_str),c_str);jstring charsetName&#x3D;(*env)-&gt;NewStringUTF(env,&quot;GB2312&quot;);&#x2F;&#x2F;实例化对象return (*env)-&gt;NewObject(env, cls, constructor_mid,byteArray,charsetName); 数据类型基本类型 Java类型 Jni类型 boolean jboolean byte jbyte char jchar short jshort int jint long jlong float jfloat double jdouble void void 引用类型 Java类型 Jni类型 String jstring Object jobject 基本类型的数组(byte[]) jByteArray …上一条类推 …上一条类推 对象数组(Object[]) jobjectArray 数组处理 传数组给C 12345678910111213141516171819202122232425262728293031323334public native void handleArray(int[] array);&#x2F;&#x2F;java调用:int[] array&#x3D;&#123;8,34,12,99,87&#125;;jniTest.handleArray(array);for(int i:array)&#123; System.out.print(&quot;\\n :&quot;+i);&#125;int compare(int* a, int* b)&#123; return (*a) - (*b);&#125;&#x2F;&#x2F;数组处理JNIEXPORT void JNICALL Java_cn_gxh_JniTest_handleArray(JNIEnv *env, jobject jobj, jintArray array)&#123; &#x2F;&#x2F;jintArray--&gt;jint指针--&gt;c int数组 jint* elements&#x3D;(*env)-&gt;GetIntArrayElements(env,array,NULL); &#x2F;&#x2F;数组的长度 jsize size&#x3D;(*env)-&gt;GetArrayLength(env,array); &#x2F;&#x2F;#include &lt;stdlib.h&gt; qsort(elements,size,sizeof(jint), compare); &#x2F;&#x2F;同步 java中的数组才会改变 &#x2F;&#x2F;参数四：0 Java数组更新，并且释放c&#x2F;c++数组 &#x2F;&#x2F;1 Java数组不更新，释放c&#x2F;c++数组 &#x2F;&#x2F;2 Java数组更新，c&#x2F;c++数组等方法执行完才释放 (*env)-&gt;ReleaseIntArrayElements(env,array,elements,0);&#125; 返回数组给Java 12345678910111213141516public native int[] getArray(int len);JNIEXPORT jintArray JNICALL Java_cn_gxh_JniTest_getArray(JNIEnv *env, jobject jobj,jint len)&#123; &#x2F;&#x2F;创建一个指定大小的数组 jintArray jint_arr&#x3D;(*env)-&gt;NewIntArray(env,len); jint* elements&#x3D;(*env)-&gt;GetIntArrayElements(env,jint_arr,NULL); int i &#x3D; 0; for (; i &lt; len;i++) &#123; elements[i] &#x3D; i; &#125; (*env)-&gt;ReleaseIntArrayElements(env, jint_arr, elements, 0); return jint_arr;&#125; JNI引用 局部引用 1234567891011121314151617181920212223局部引用需要手动释放对象的场景：1.访问一个很大的java对象，使用完后，还要进行复杂的耗时操作2.创建了大量的局部引用，占用了太多的内存，而且后面不再使用它了要通过DeleteLocalRef手动释放对象JNIEXPORT void JNICALL Java_cn_gxh_JniTest_localRef(JNIEnv *env, jobject jobj)&#123; int i &#x3D; 0; for (;i&lt;5; i++) &#123; jclass cls&#x3D; (*env)-&gt;FindClass(env, &quot;java&#x2F;util&#x2F;Date&quot;); jmethodID constructor_mid &#x3D; (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;); &#x2F;&#x2F;实例化对象 jobject date_obj &#x3D; (*env)-&gt;NewObject(env, cls, constructor_mid); &#x2F;&#x2F;代码省略了... &#x2F;&#x2F;通知垃圾回收器回收这些对象 (*env)-&gt;DeleteLocalRef(env,date_obj); &#x2F;&#x2F;下面的代码不再使用date_obj &#125;&#125; 全局引用 123456789101112131415161718全局引用好处就是多个方法可以共享这个变量。&#x2F;&#x2F;全局引用jstring global_str;JNIEXPORT void JNICALL Java_cn_gxh_JniTest_deleteGlobalRef(JNIEnv *env, jobject jobj)&#123; (*env)-&gt;DeleteGlobalRef(env,global_str);&#125;JNIEXPORT void JNICALL Java_cn_gxh_JniTest_createGlobalRef(JNIEnv *env, jobject jobj)&#123; jstring obj&#x3D;(*env)-&gt;NewStringUTF(env,&quot;life is but a span &quot;); global_str&#x3D;(*env)-&gt;NewGlobalRef(env,obj);&#125; 异常12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F;异常JNIEXPORT void JNICALL Java_cn_gxh_JniTest_exception(JNIEnv *env, jobject jobj)&#123; jclass cls &#x3D; (*env)-&gt;GetObjectClass(env, jobj); jfieldID fid &#x3D; (*env)-&gt;GetFieldID(env, cls, &quot;key2&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); printf(&quot;执行了...&quot;);&#125;没有key2这个属性，导致了运行后Java层异常，Exception in thread &quot;main&quot; java.lang.NoSuchFieldError: key2但是在Java中，try catch Exception是捕捉不到的。JNI抛出的是Throwable异常，只能捕捉Throwable异常。想在JNI处理了异常怎么办呢？检测异常--&gt;清空异常&#x2F;&#x2F;异常JNIEXPORT void JNICALL Java_cn_gxh_JniTest_exception(JNIEnv *env, jobject jobj)&#123; jclass cls &#x3D; (*env)-&gt;GetObjectClass(env, jobj); jfieldID fid &#x3D; (*env)-&gt;GetFieldID(env, cls, &quot;key2&quot;, &quot;Ljava&#x2F;lang&#x2F;String;&quot;); printf(&quot;执行了...&quot;); &#x2F;&#x2F;检测是否发生Java异常 jthrowable exception&#x3D;(*env)-&gt;ExceptionOccurred(env); if (exception!&#x3D;NULL) &#123; &#x2F;&#x2F;清空异常信息 (*env)-&gt;ExceptionClear(env); &#x2F;&#x2F;发生异常后的其他业务逻辑代码 &#125;&#125;这样Java层就没有异常了。JNI层也可以人为抛异常给Java层，这样Java可以try catch Exception。&#x2F;&#x2F;人为抛异常给Java层处理jclass e_cls&#x3D;(*env)-&gt;FindClass(env,&quot;java&#x2F;lang&#x2F;IllegalArgumentException&quot;);(*env)-&gt;ThrowNew(env,e_cls,&quot;key2 not exist&quot;); 缓存策略如果JNI方法里有局部静态(static)变量，在方法初始化的时候，这个变量也被初始化(不管这个方法调用多少次，这个变量只会初始化一次)，方法结束后，这个变量依然会存储在内存中，直到整个程序结束。也就是它的作用域就是这个方法，但是生命周期很长。 如果我们需要一些全局的静态变量，一般可以在一个方法里全部初始化完成。而这个方法在我们加载完动态库后马上调用。","link":"","tags":[{"name":"ndk","slug":"ndk","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/ndk/"},{"name":"jni","slug":"jni","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/jni/"}]},{"title":"哈夫曼树和哈夫曼编码","date":"2019-03-26T01:31:00.000Z","path":"2019/03/26/2019.02.20 哈夫曼树和哈夫曼编码/","text":"通常的编码方法有固定长度和不等长度编码。最优编码方案的目的是使总码长度最短。 如果采用等长的编码方案，假设所有字符的编码都等长，则表示n个不同的字符需要位，例如三个不同的字符abc，至少需要2位二进制数表示：a(00)、b(01)、c(10)。如果每个字符的使用频率相等的话，固定长度编码是空间效率最高的方法。 那么问题来了，等长编码方案，n个不同字符需要几位来表示呢？log2n取上限。 利用字符的使用频率来编码，是不等长编码方法，使得经常使用的字符编码较短，不常使用的字符编码较长。 不等长编码需要解决两个关键问题： 编码尽可能短 12使用频率高的字符编码较短，使用频率低的编码较长，可提高压缩率，节省空间，也能提高运算和通信速度。即**频率越高，编码越短**。 不能有二义性 例如a(0)、b(1)、c(01)，那么传输的01001就不知道到底是什么了，开头的01，可以说是ab，也可以说是c。这就是二义性。 123解决二义性：任何一个字符的编码不能是另一个字符编码的前缀。即**前缀码特性**。 1952年，数学家D.A.Huffman提出了用字符在文件中出现的频率来建议一个用0，1串表示各字符的最佳编码方式，成为Huffman编码。哈夫曼编码很好的解决了上述两个关键的问题，广泛地应用于数据压缩、尤其是远距离通信和大容量数据存储，常用的JPEG图片就是采用哈夫曼编码压缩的。 哈夫曼编码的基本思想就是以字符的使用频率来构建一棵哈夫曼树，然后利用哈夫曼树对字符进行编码。 哈夫曼树构建哈夫曼树，是将所要编码的字符作为叶子结点，该字符在文件中使用的频率作为叶子结点的权值，自底向上的方式，通过n-1次的“合并”运算后构造出来的树。核心思想是让权值大的叶子离根最近。 哈夫曼算法采取的贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树(一般情况下有个约定，两棵树中权值最小的为左子树)，构建一棵新树，新树根结点的权值为其左右孩子结点权值之和，将新树插入到树的集合中。这也是构建哈夫曼树的步骤。 字符 a b c d e f 频率 0.05 0.32 0.18 0.07 0.25 0.13 我们把频率扩大100倍，不会影响结果。 我们从T集合中选没有双亲且权值最小的两棵树作为左右子树，也就是a和d，那么ad构建的新树的根结点权值为5+7=12。将这个新树t1加入到T集合再进行比较，ad不再进行比较了。 选没有双亲且权值最小的两棵树作为左右子树，也就是t1,f。那么t1和f构建的新树的根结点权值为12+13=25。将这个新树t2加入到T集合再进行比较，t1和f不再进行比较了。 选没有双亲且权值最小的两棵树作为左右子树，c的权值18最小了，作为左子树，而t2和e权值都是25，选谁作为右子树呢？选e。理由就是选前面的，新构建的树在T集合的后面。那么c和e构建的新树的根结点权值为18+25=43。将这个新树t3加入到T集合再进行比较，t2和e不再进行比较了。 以此类推… 那么我们这里再说一个哈夫曼树带权路径长度。WPL=每个叶子的权值*该叶子到根的路径长度之和。叶子到根的路径长度为路径分支数(边数)。例如结点c到根经过两个边，其到根的路径长度为2。所以上面这个哈夫曼树的带权路径为 118*2+25*2+5*4+7*4+13*+32*2&#x3D;237 当然了还有一种计算方法，哈夫曼树的带权路径长度之和等于各新生结点的权值之和。 1100+43+12+25+57&#x3D;237 注意的是我们这里是扩大了100倍的，也就是说相当于有100个字符。那么如果有10^6^个字符，其哈夫曼树编码的长度时多少呢？10^6^*237/100 哈夫曼编码前言 确定合适的数据结构，顺序存储。 哈夫曼树中没有深度为1的结点，则一棵有n个叶子结点的哈夫曼树共有2n-1个结点。 构成哈夫曼树后，编码需从叶子结点出发走一条到根的路径。 译码需要从根出发走一条从根到叶子的路径。对每一个结点而言，需要知道它的权值、双亲、左孩子、有孩子和结点信息。 什么是哈夫曼编码利用哈夫曼树求得的用于通信的二进制编码称为哈夫曼编码。树中从根到每个叶子结点都有一条路径，对路径上的各分支约定指向左子树的分支表示”0”码，指向右子树的分支表示“1”码，取每条路径上的“0”或“1”的序列作为各个叶子结点对应的字符编码，即是哈夫曼编码。 带权路径长度可以看做最终编码的二进制长度。 a的编码为：1000 代码分析构建哈夫曼树是一个填表的过程，哈夫曼编码是一个读表的过程。 下标 weight parent lchild rchild value 0 5 -1 -1 -1 a 1 32 -1 -1 -1 b 2 18 -1 -1 -1 c 3 7 -1 -1 -1 d 4 25 -1 -1 -1 e 5 13 -1 -1 -1 f 6 -1 -1 -1 -1 7 -1 -1 -1 -1 8 -1 -1 -1 -1 9 -1 -1 -1 -1 10 -1 -1 -1 -1 ad构建的新树t1的根结点权值为5+7=12。保存在下标为6。对应下标为6的weight为12，lchild就是a，所以保存a的下标0，同理rchild保存的是d的下标3。同时a和d的parent就知道了，也就是下标6。所以每次构建一个新树，需要改动表里5个地方。以此类推… 下标 weight parent lchild rchild value 0 5 6 -1 -1 a 1 32 9 -1 -1 b 2 18 8 -1 -1 c 3 7 6 -1 -1 d 4 25 8 -1 -1 e 5 13 7 -1 -1 f 6 12 7 0 3 7 25 9 6 5 8 43 10 2 4 9 57 10 7 1 10 100 -1 8 9 读表怎么读呢？比如我们想知道a的编码，我们读表知道a的parent是6，6的lchild为0正好是a的下标，也就是说a是左分支，所以这个分支编码为0。接着找6的parent，以此类推，直到parent为-1。这也是从叶子a到根的过程，保存路径各分支的编码，从根到叶子a的编码序列即为a的编码。(找是从叶子到根，但是找完了读还是从根到叶子。) 12345typedef struct&#123; int bit[MAXBIT];&#x2F;&#x2F;存储编码的数组 int start;&#x2F;&#x2F;编码开始的下标&#125; HCodeType; &#x2F;* 编码结构体 *&#x2F; 这里每个叶子结点都使用了一个定长数组，是比较浪费空间的，可以动态创建。 全部代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;#define MAXBIT 100#define MAXVALUE 10000#define MAXLEAF 30#define MAXNODE MAXLEAF*2 -1typedef struct&#123; double weight; int parent; int lchild; int rchild; char value;&#125; HNodeType; &#x2F;* 结点结构体 *&#x2F;typedef struct&#123; int bit[MAXBIT]; int start;&#125; HCodeType; &#x2F;* 编码结构体 *&#x2F;HNodeType HuffNode[MAXNODE]; &#x2F;* 定义一个结点结构体数组 *&#x2F;HCodeType HuffCode[MAXLEAF];&#x2F;* 定义一个编码结构体数组*&#x2F;&#x2F;* 构造哈夫曼树 *&#x2F;void HuffmanTree (HNodeType HuffNode[MAXNODE], int n)&#123; &#x2F;* i、j： 循环变量，m1、m2：构造哈夫曼树不同过程中两个最小权值结点的权值， x1、x2：构造哈夫曼树不同过程中两个最小权值结点在数组中的序号。*&#x2F; int i, j, x1, x2; double m1,m2; &#x2F;* 初始化存放哈夫曼树数组 HuffNode[] 中的结点 *&#x2F; for (i&#x3D;0; i&lt;2*n-1;i++) &#123; HuffNode[i].weight&#x3D;0;&#x2F;&#x2F;权值 HuffNode[i].parent&#x3D;-1; HuffNode[i].lchild&#x3D;-1; HuffNode[i].rchild&#x3D;-1; &#125; &#x2F;* 输入 n 个叶子结点的权值 *&#x2F; for (i&#x3D;0; i&lt;n; i++) &#123; cout&lt;&lt;&quot;Please input value and weight of leaf node &quot;&lt;&lt;i+1&lt;&lt;endl; cin&gt;&gt;HuffNode[i].value&gt;&gt;HuffNode[i].weight; &#125; &#x2F;* 构造 Huffman 树 *&#x2F; for (i&#x3D;0; i&lt;n-1; i++) &#123;&#x2F;&#x2F;执行n-1次合并 m1&#x3D;m2&#x3D;MAXVALUE; &#x2F;* m1、m2中存放两个无父结点且结点权值最小的两个结点 *&#x2F; x1&#x3D;x2&#x3D;0; &#x2F;* 找出所有结点中权值最小、无父结点的两个结点，并合并之为一棵二叉树 *&#x2F; for (j&#x3D;0;j&lt;n+i;j++) &#123; if (HuffNode[j].weight&lt;m1&amp;&amp;HuffNode[j].parent&#x3D;&#x3D;-1) &#123; m2 &#x3D; m1; x2 &#x3D; x1; m1 &#x3D; HuffNode[j].weight; x1 &#x3D; j; &#125; else if (HuffNode[j].weight &lt; m2 &amp;&amp; HuffNode[j].parent&#x3D;&#x3D;-1) &#123; m2&#x3D;HuffNode[j].weight; x2&#x3D;j; &#125; &#125; &#x2F;* 设置找到的两个子结点 x1、x2 的父结点信息 *&#x2F; HuffNode[x1].parent &#x3D; n+i; HuffNode[x2].parent &#x3D; n+i; HuffNode[n+i].weight &#x3D; m1+m2; HuffNode[n+i].lchild &#x3D; x1; HuffNode[n+i].rchild &#x3D; x2; cout&lt;&lt;&quot;x1.weight and x2.weight in round &quot;&lt;&lt;i+1&lt;&lt;&quot;\\t&quot;&lt;&lt;HuffNode[x1].weight&lt;&lt;&quot;\\t&quot;&lt;&lt;HuffNode[x2].weight&lt;&lt;endl; &#x2F;* 用于测试 *&#x2F; &#125;&#125;&#x2F;* 哈夫曼树编码 *&#x2F;void HuffmanCode(HCodeType HuffCode[MAXLEAF], int n)&#123; HCodeType cd; &#x2F;* 定义一个临时变量来存放求解编码时的信息 *&#x2F; int i,j,c,p; for(i&#x3D;0;i&lt;n;i++) &#123; cd.start&#x3D;n-1; c&#x3D;i; p&#x3D;HuffNode[c].parent; while(p!&#x3D;-1) &#123; if(HuffNode[p].lchild&#x3D;&#x3D;c) cd.bit[cd.start]&#x3D;0; else cd.bit[cd.start]&#x3D;1; cd.start--; &#x2F;*前移一位 *&#x2F; c&#x3D;p; p&#x3D;HuffNode[c].parent; &#x2F;* 设置下一循环条件 *&#x2F; &#125; &#x2F;* 把叶子结点的编码信息从临时编码cd中复制出来，放入编码结构体数组 *&#x2F; for (j&#x3D;cd.start+1; j&lt;n; j++) HuffCode[i].bit[j]&#x3D;cd.bit[j]; HuffCode[i].start&#x3D;cd.start; &#125;&#125;int main()&#123; int i,j,n; cout&lt;&lt;&quot;Please input n:&quot;&lt;&lt;endl; cin&gt;&gt;n; HuffmanTree(HuffNode,n); &#x2F;&#x2F;构造哈夫曼树 HuffmanCode(HuffCode,n); &#x2F;&#x2F; 哈夫曼树编码 &#x2F;&#x2F;输出已保存好的所有存在编码的哈夫曼编码 for(i&#x3D;0;i&lt;n;i++) &#123; cout&lt;&lt;HuffNode[i].value&lt;&lt;&quot;: Huffman code is: &quot;; for(j&#x3D;HuffCode[i].start+1;j&lt;n;j++) cout&lt;&lt;HuffCode[i].bit[j]; cout&lt;&lt;endl; &#125; return 0;&#125;","link":"","tags":[{"name":"算法","slug":"算法","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/%E7%AE%97%E6%B3%95/"},{"name":"哈夫曼","slug":"哈夫曼","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/%E5%93%88%E5%A4%AB%E6%9B%BC/"}]},{"title":"二叉树","date":"2019-03-22T09:48:00.000Z","path":"2019/03/22/二叉树/","text":"树什么是树？树(Tree)是n(n≥)个节点的有限集合。当n=0时为空树，n&gt;0时为非空树。 任意一棵非空树满足： 有且仅有一个称之为根的节点 除了根节点以外的节点可以分为m(m&gt;0)个互不相交的有限集，每一个集合本身又是一棵树，并且成为根的子数(SubTree)。 另外，还有一些其它概念需要知道。 结点 结点包含数据元素及若干指向子树的分支信息。 结点的度 结点拥有的子树个数。图中A结点的度是3，结点D没有子树，也就是度为0，所以结点D也称之为叶子。 树的度 树中结点的最大度数。 终端结点 度为0的结点，也称为叶子。 分支结点 度大于0的结点。除了叶子都是分支结点。 内部结点 除了树根和叶子都是内部结点。 结点的层次 从根到该结点的层数(“根结点为第1层”不同的书有不同说法)。 树的深度高度 指所有结点中最大层数。图中树的深度为4。 路径 树中两个结点之间的所经过的结点序列。 路径长度 两节点之间路径上经过的边数。比如结点A到E，路径长度为2。 双亲、孩子 结点的子树的根称为该结点的孩子。图中E、F是B的孩子。B、C、D是A的孩子。A就是BCD的双亲。 兄弟 同一个双亲的都是兄弟。 堂兄弟 双亲是亲兄弟的。 祖先 从当前结点到根节点之间所有的结点都是该结点的祖先。图中A、B就是F的祖先。 子孙 子树所有的结点。 有序树 结点的各子树从左到右，不能互换位置。如果图中是一个有序树，那么B就是长子，C是次子。 无序树 结点的各子树可以互换位置。 森林 由m(≥)棵不相交的树组成的集合。 树的存储采用顺序存储和链式存储两种方式。 顺序存储双亲表示法结点A是没有双亲的，所以parent为-1。结点B的双亲是A，存储A的下标0，即parent为0。以此类推即可。那么问题来了？我们直接记录结点数据不就行了吗？为什么记录下标呢？是因为结点数据可能太大。 下标 data parent 0 A -1 1 B 0 2 C 0 3 D 0 4 E 1 5 F 1 6 G 2 7 H 5 孩子表示法树的度为3，孩子表示法每个结点就会开辟3个孩子域。A有三个孩子，记录下三个孩子的下标。B有两个孩子，剩下的一个孩子域就是-1。 可见，孩子表示法比较浪费空间。但它的好处是找孩子容易。下标 |data | child| child| child—|—|—|—|—0 |A | 1|2|31 |B |4|5|-12 |C |6|-1|-13 |D |-1|-1|-14 |E |-1|-1|-15 |F |7|-1|-16 |G |-1|-1|-17 |H |-1|-1|-1 双亲孩子表示法 下标 data parent child child child 0 A -1 1 2 3 1 B 0 4 5 -1 2 C 0 6 -1 -1 3 D 0 -1 -1 -1 4 E 1 -1 -1 -1 5 F 1 7 -1 -1 6 G 2 -1 -1 -1 7 H 5 -1 -1 -1 链式存储孩子兄弟表示法左指针指向长子，右指针指向兄弟。兄弟关系在右斜线上。 普通的树不好存储，因为每个结点孩子数不固定。我们可以用孩子兄弟表示法，将树转为二叉树。那么森林转二叉树呢？我们需要把每棵树看作兄弟。将二叉树转为书或者森林呢？凡是右斜线的都是兄弟，都断开。 将上述树转为二叉树： 二叉树什么是二叉树？二叉树(Binary Tree)是n(n≥)个结点的有限集合。当n=0时为空树，n&gt;0时为非空树。 任意一棵非空树满足： 有且仅有一个称之为根的结点 除了根结点以外的结点可以分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身都是二叉树。 什么是满二叉树？ 一棵深度为k且有(2^k)-1个结点的二叉树。 什么是完全二叉树？ 除了最后一层外，每一层都是满的(达到最大结点数)，最后一层结点是从左向右出现的。 二叉树的性质 在二叉树的第i层上至多有2^i-1^个结点。 1二叉树每个结点最多两个叉。第一层也就是根结点，只有一个(2^0)。第二层最多两个结点(2^1)。以此类推。 深度为k的二叉树至多有2^k^-1个结点 1根据性质1可知，每一层至多结点数是等比数列。 对于任何一课二叉树，若叶子数为m，度为2的结点数为n，则m=n+1 12345在二叉树中，有三种结点：度为0的、度为1的、度为2的。分别设为n1,n2,n3 总结点数n，即n&#x3D;n1+n2+n3已知结点数n&#x3D;分支数B+1而分支数B&#x3D;2*n3+n1推出n3+1&#x3D;n2 具有n个结点的完全二叉树的深度必为log2n+1 设这个完全二叉树深度为h，那么最少2^h-1^-1+1个结点，至多2^h^-1个结点。所以2^h-1^≤n≤2^h^-1&lt;2^h^ 同时取对数，h-1≤log2n&lt;h，所以h-1=log2n，h=log2n+1 对于完全二叉树，若从上至下、从左到右编号，则编号为i的结点，其左孩子编号为2i，右孩子编号为2i+1，其双亲 编号为i/2 二叉树的存储二叉树的存储我们可以用顺序存储。通过补0补成完全二叉树。但是这种存储有个缺点就是可能补0太多，就像我们上文中那个二叉树。所以除非这个树是完全二叉树，我们才用顺序存储，否则不用。 二叉树可以用链式存储。左指针指向长子，右指针指向兄弟。没有就空。 二叉树遍历按照根的访问顺序不同，根在前面称为先序遍历(DLR),根在中间称为中序遍历(LDR),根在最后称为后序遍历(LRD)。 先序遍历先序遍历是指先访问根，然后先序遍历左子树，再先序遍历右子树。如果二叉树为空，则空操作。 先序遍历秘籍：访问根，先序遍历左子树，左子树为空或已遍历才可以遍历右子树。 以上文中二叉树图为例，先序遍历为：ABEFHCGD 中序遍历是指中序遍历左子树，然后访问根，再中序遍历右子树。 以上文中二叉树图为例，先序遍历为：EHFBGCDA 后序遍历后序遍历是指后序遍历左子树，后序遍历右子树，再访问根。所以后序遍历最后一个一定是根。 以上文中二叉树图为例，先序遍历为：HFEGDCBA 层次遍历一层一层的遍历，每一层从左向右。可以用队列控制。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;queue&gt;&#x2F;&#x2F;引入队列头文件using namespace std;typedef struct Bnode &#x2F;*定义二叉树存储结构*&#x2F;&#123; char data; struct Bnode *lchild,*rchild;&#125;Bnode,*Btree;void Createtree(Btree &amp;T) &#x2F;*创建二叉树函数*&#x2F;&#123; &#x2F;&#x2F;按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T char ch; cin &gt;&gt; ch; if(ch&#x3D;&#x3D;&#39;#&#39;) T&#x3D;NULL; &#x2F;&#x2F;递归结束，建空树 else&#123; T&#x3D;new Bnode; T-&gt;data&#x3D;ch; &#x2F;&#x2F;生成根结点 Createtree(T-&gt;lchild); &#x2F;&#x2F;递归创建左子树 Createtree(T-&gt;rchild); &#x2F;&#x2F;递归创建右子树 &#125;&#125;void preorder(Btree T)&#x2F;&#x2F;先序遍历&#123; if(T) &#123; cout&lt;&lt;T-&gt;data&lt;&lt;&quot; &quot;; preorder(T-&gt;lchild); preorder(T-&gt;rchild); &#125;&#125;void inorder(Btree T)&#x2F;&#x2F;中序遍历&#123; if(T) &#123; inorder(T-&gt;lchild); cout&lt;&lt;T-&gt;data&lt;&lt;&quot; &quot;; inorder(T-&gt;rchild); &#125;&#125;void posorder(Btree T)&#x2F;&#x2F;后序遍历&#123; if(T) &#123; posorder(T-&gt;lchild); posorder(T-&gt;rchild); cout&lt;&lt;T-&gt;data&lt;&lt;&quot; &quot;; &#125;&#125;bool Leveltraverse(Btree T)&#123; Btree p; if(!T) return false; queue&lt;Btree&gt;Q; &#x2F;&#x2F;创建一个普通队列(先进先出)，里面存放指针类型 Q.push(T); &#x2F;&#x2F;根指针入队 while(!Q.empty()) &#x2F;&#x2F;如果队列不空 &#123; p&#x3D;Q.front();&#x2F;&#x2F;取出队头元素作为当前扩展结点livenode Q.pop(); &#x2F;&#x2F;队头元素出队 cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; if(p-&gt;lchild) Q.push(p-&gt;lchild); &#x2F;&#x2F;左孩子指针入队 if(p-&gt;rchild) Q.push(p-&gt;rchild); &#x2F;&#x2F;右孩子指针入队 &#125; return true;&#125;int main()&#123; Btree mytree; cout&lt;&lt;&quot;按先序次序输入二叉树中结点的值（孩子为空时输入#），创建一棵二叉树&quot;&lt;&lt;endl; Createtree(mytree);&#x2F;&#x2F;创建二叉树 cout&lt;&lt;endl; cout&lt;&lt;&quot;二叉树的先序遍历结果：&quot;&lt;&lt;endl; preorder(mytree);&#x2F;&#x2F;先序遍历二叉树 cout&lt;&lt;endl; cout&lt;&lt;&quot;二叉树的中序遍历结果：&quot;&lt;&lt;endl; inorder(mytree);&#x2F;&#x2F;中序遍历二叉树 cout&lt;&lt;endl; cout&lt;&lt;&quot;二叉树的后序遍历结果：&quot;&lt;&lt;endl; posorder(mytree);&#x2F;&#x2F;后序遍历二叉树 cout&lt;&lt;endl; cout&lt;&lt;&quot;二叉树的层次遍历结果：&quot;&lt;&lt;endl; Leveltraverse(mytree);&#x2F;&#x2F;层次遍历二叉树 return 0;&#125; 二叉树创建补空法是指如果左子树或者右子树为空时，则用特殊符号补空，如“#”。然后按照先序遍历的顺利，得到先序遍历序列，根据该序列递归创建二叉树。 算法步骤： 输入补空后的二叉树先序遍历序列。 如果ch==“#”，T=NULL；否则创建一个新结点T，令T-&gt;data=ch；递归创建T的左子树；递归创建T的右子树。 二叉树还原注意：只知道先序和后序序列，是没办法还原一个二叉树的。 例如：已知一棵二叉树的先序序列ABDECFG和中序序列DBEAFGC，画出这棵二叉树。 算法步骤： 先序序列第一个字符为根。 在中序序列中，以根为中心划分左右子树。 还原左右子树。 例如：已知一棵二叉树的后序序列为DEBGFCA和中序序列DBEAFGC，画出这棵二叉树。答案也是上图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;using namespace std;typedef struct node&#123; char data; struct node *lchild,*rchild;&#125;BiTNode,*BiTree;BiTree pre_mid_createBiTree(char *pre,char *mid,int len) &#x2F;&#x2F;前序中序还原建立二叉树&#123; if(len&#x3D;&#x3D;0) return NULL; char ch&#x3D;pre[0]; &#x2F;&#x2F;找到先序中的第一个结点 int index&#x3D;0; while(mid[index]!&#x3D;ch)&#x2F;&#x2F;在中序中找到的根结点的左边为该结点的左子树，右边为右子树 &#123; index++; &#125; BiTree T&#x3D;new BiTNode;&#x2F;&#x2F;创建根结点 T-&gt;data&#x3D;ch; T-&gt;lchild&#x3D;pre_mid_createBiTree(pre+1,mid,index);&#x2F;&#x2F;建立左子树 T-&gt;rchild&#x3D;pre_mid_createBiTree(pre+index+1,mid+index+1,len-index-1);&#x2F;&#x2F;建立右子树 return T;&#125;BiTree pro_mid_createBiTree(char *last,char *mid,int len)&#x2F;&#x2F;后序中序还原建立二叉树&#123; if(len&#x3D;&#x3D;0) return NULL; char ch&#x3D;last[len-1]; &#x2F;&#x2F;取得后序遍历顺序中最后一个结点 int index&#x3D;0;&#x2F;&#x2F;在中序序列中找根结点，并用index记录长度 while(mid[index]!&#x3D;ch)&#x2F;&#x2F;在中序中找到根结点，左边为该结点的左子树，右边为右子树 index++; BiTree T&#x3D;new BiTNode;&#x2F;&#x2F;创建根结点 T-&gt;data&#x3D;ch; T-&gt;lchild&#x3D;pro_mid_createBiTree(last,mid,index);&#x2F;&#x2F;建立左子树 T-&gt;rchild&#x3D;pro_mid_createBiTree(last+index,mid+index+1,len-index-1);&#x2F;&#x2F;建立右子树 return T;&#125;void pre_order(BiTree T)&#x2F;&#x2F;前序递归遍历二叉树&#123; if(T) &#123; cout&lt;&lt;T-&gt;data; pre_order(T-&gt;lchild); pre_order(T-&gt;rchild); &#125;&#125;void pro_order(BiTree T)&#x2F;&#x2F;后序递归遍历二叉树&#123; if(T) &#123; pro_order(T-&gt;lchild); pro_order(T-&gt;rchild); cout&lt;&lt;T-&gt;data; &#125;&#125;int main()&#123; BiTree T; int n; char pre[100],mid[100],last[100]; cout&lt;&lt;&quot;1. 前序中序还原二叉树\\n&quot;; cout&lt;&lt;&quot;2. 后序中序还原二叉树\\n&quot;; cout&lt;&lt;&quot;0. 退出\\n&quot;; int choose&#x3D;-1; while(choose!&#x3D;0) &#123; cout&lt;&lt;&quot;请选择:&quot;; cin&gt;&gt;choose; switch (choose) &#123; case 1:&#x2F;&#x2F;前序中序还原二叉树 cout&lt;&lt;&quot;请输入结点的个数:&quot;&lt;&lt;endl; cin&gt;&gt;n; cout&lt;&lt;&quot;请输入前序序列:&quot;&lt;&lt;endl; for(int i&#x3D;0;i&lt;n;i++) cin&gt;&gt;pre[i]; cout&lt;&lt;&quot;请输入中序序列:&quot;&lt;&lt;endl; for(int i&#x3D;0;i&lt;n;i++) cin&gt;&gt;mid[i]; T&#x3D;pre_mid_createBiTree(pre,mid,n); cout&lt;&lt;endl; cout&lt;&lt;&quot;二叉树还原成功，输出其后序序列:&quot;&lt;&lt;endl; pro_order(T); cout&lt;&lt;endl&lt;&lt;endl; break; case 2:&#x2F;&#x2F;后序中序还原二叉树 cout&lt;&lt;&quot;请输入结点的个数:&quot;&lt;&lt;endl; cin&gt;&gt;n; cout&lt;&lt;&quot;请输入后序序列:&quot;&lt;&lt;endl; for(int i&#x3D;0 ;i&lt;n;i++) cin&gt;&gt;last[i]; cout&lt;&lt;&quot;请输入中序序列:&quot;&lt;&lt;endl; for(int i&#x3D;0 ;i&lt;n;i++) cin&gt;&gt;mid[i]; T&#x3D;pro_mid_createBiTree(last,mid,n); cout&lt;&lt;endl; cout&lt;&lt;&quot;二叉树还原成功，输出其先序序列:&quot;&lt;&lt;endl; pre_order(T); cout&lt;&lt;endl&lt;&lt;endl; break; &#125; &#125; return 0;&#125; 求叶子和结点数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;using namespace std;typedef struct Bnode &#x2F;*定义二叉树存储结构*&#x2F;&#123; char data; struct Bnode *lchild,*rchild;&#125;Bnode,*Btree;void Createtree(Btree &amp;T) &#x2F;*创建二叉树函数*&#x2F;&#123; &#x2F;&#x2F;按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T char ch; cin &gt;&gt; ch; if(ch&#x3D;&#x3D;&#39;#&#39;) T&#x3D;NULL; &#x2F;&#x2F;递归结束，建空树 else&#123; T&#x3D;new Bnode; T-&gt;data&#x3D;ch; &#x2F;&#x2F;生成根结点 Createtree(T-&gt;lchild); &#x2F;&#x2F;递归创建左子树 Createtree(T-&gt;rchild); &#x2F;&#x2F;递归创建右子树 &#125;&#125;int LeafCount(Btree T)&#x2F;&#x2F;求二叉树的叶子数&#123; if(T&#x3D;&#x3D;NULL)&#x2F;&#x2F;如果为空树，深度为0 return 0; else if(T-&gt;lchild&#x3D;&#x3D;NULL&amp;&amp;T-&gt;rchild&#x3D;&#x3D;NULL)&#x2F;&#x2F;左右子树均为空，则叶子数为1 return 1; else return LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);&#x2F;&#x2F;递归计算左子树和右子树的叶子数之和&#125;int NodeCount(Btree T)&#x2F;&#x2F;求二叉树的结点数&#123; if(T&#x3D;&#x3D;NULL)&#x2F;&#x2F;如果为空树，深度为0 return 0; else return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1;&#x2F;&#x2F;递归计算左子树和右子树的结点数之和加1&#125;int Depth(Btree T)&#x2F;&#x2F;求二叉树的深度&#123; int m,n; if(T&#x3D;&#x3D;NULL)&#x2F;&#x2F;如果为空树，深度为0 return 0; else &#123; m&#x3D;Depth(T-&gt;lchild);&#x2F;&#x2F;递归计算左子树深度 n&#x3D;Depth(T-&gt;rchild);&#x2F;&#x2F;递归计算左子树深度 if(m&gt;n) return m+1;&#x2F;&#x2F;返回左右子树最大值加1 else return n+1; &#125;&#125;int main()&#123; Btree mytree; cout&lt;&lt;&quot;按先序次序输入二叉树中结点的值（孩子为空时输入#），创建一棵二叉树&quot;&lt;&lt;endl; &#x2F;&#x2F;ABD##E##CF#G### Createtree(mytree);&#x2F;&#x2F;创建二叉树 cout&lt;&lt;endl; cout&lt;&lt;&quot;二叉树的结点数为：&quot;&lt;&lt;NodeCount(mytree)&lt;&lt;endl; cout&lt;&lt;&quot;二叉树的叶子数为：&quot;&lt;&lt;LeafCount(mytree)&lt;&lt;endl; return 0;&#125;","link":"","tags":[{"name":"算法","slug":"算法","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Android中的消息机制Handler","date":"2019-03-12T15:59:00.000Z","path":"2019/03/12/Android中的消息机制Handler/","text":"什么是Handler？1234Handler是安卓消息机制的一个上层接口。handler通过发送和处理Message和Runnable对象来关联相对应线程的MessageQueue。1.可以让对应的Message和Runnable在未来某个时间点进行相应处理。2.让自己想要处理的耗时操作放在子线程，让更新ui的操作放在主线程。 Handler的使用1234567891011121314151617181920212223private Handler mHandler &#x3D; new Handler() &#123; @Override public void handleMessage(Message msg) &#123; &#125;&#125;;&#x2F;&#x2F;主线程执行的Runnable runnable &#x3D; new Runnable() &#123; @Override public void run() &#123; mHandler.postDelayed(runnable, 1000); &#125;&#125;;&#x2F;&#x2F;方式1:mHandler.post(runnable);&#x2F;&#x2F;方式2:Message msg&#x3D;Message.obtain();msg.what&#x3D;1;mHandler.sendMessage(msg); Handler的使用主要有两种方式，如上。 方式1内部其实也是调用的sendMessage(msg)方法，但是它不会交给Handler的handleMessage(Message msg)来处理，而是调用Runnable的run()方法。这种主要在定时循环的需求上使用。 方式2是直接发了一个Message消息，最终会由Handler的handleMessage(Message msg)来处理。这种方式往往在子线程调用，用来更新UI。 这里可能大家会有个疑问，Looper呢？不是说Looper是用来循环读取消息的吗？在哪里呢？其实我们看ActivityThread的源码就知道了。程序启动的时候已经帮我们创建了Looper，并且开启了循环loop()。 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); SamplingProfilerIntegration.start(); &#x2F;&#x2F; CloseGuard defaults to true and can be quite spammy. We &#x2F;&#x2F; disable it here, but selectively enable it later (via &#x2F;&#x2F; StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); &#x2F;&#x2F; Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); &#x2F;&#x2F; Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir &#x3D; Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); &#x2F;&#x2F;创建Looper Looper.prepareMainLooper(); ActivityThread thread &#x3D; new ActivityThread(); thread.attach(false); if (sMainThreadHandler &#x3D;&#x3D; null) &#123; sMainThreadHandler &#x3D; thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; &#x2F;&#x2F; End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#x2F;&#x2F;开启循环 Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 所以，我们使用的时候不再创建Looper。但是我们要在子线程去轮询并处理消息呢？是需要我们自己创建Looper的。 1234567891011121314151617181920212223242526private void startThread()&#123; MyThread myThread&#x3D;new MyThread(); myThread.start(); Message msg&#x3D;Message.obtain(); myThread.handler.sendMessage(msg);&#125;class MyThread extends Thread&#123; Handler handler; @Override public void run() &#123; Looper.prepare(); handler&#x3D;new Handler()&#123; @Override public void handleMessage(Message msg) &#123; &#125; &#125;; Looper.loop(); &#125;&#125; Handler 核心类与源码分析MessageMessgae是在线程之间传送的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。Message的what子段表示携带了什么类型的信息，obj字段表示携带一个Object对象。 Message的创建 1234567891011121314151617&#x2F;** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. *&#x2F;public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool !&#x3D; null) &#123; Message m &#x3D; sPool; sPool &#x3D; m.next; m.next &#x3D; null; m.flags &#x3D; 0; &#x2F;&#x2F; clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; 我们创建消息，应避免使用new Message()的方式，而是使用obtain()。这个方法会从一个全局的pool里返回一个实例，避免分配过多的内存。其实采用了单链表存储已经回收了的Message，会每次取头结点的Message来复用，取完后第二个节点变成了头结点，单链表长度-1。当然了，没有可利用的Message，还是会默认通过new Message()来创建。 Message的回收 1234567891011121314151617181920212223void recycleUnchecked() &#123; &#x2F;&#x2F; Mark the message as in use while it remains in the recycled object pool. &#x2F;&#x2F; Clear out all other details. flags &#x3D; FLAG_IN_USE; what &#x3D; 0; arg1 &#x3D; 0; arg2 &#x3D; 0; obj &#x3D; null; replyTo &#x3D; null; sendingUid &#x3D; -1; when &#x3D; 0; target &#x3D; null; callback &#x3D; null; data &#x3D; null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next &#x3D; sPool; sPool &#x3D; this; sPoolSize++; &#125; &#125;&#125; Message回收后，存储回收Message的单链表会将该Message添加为头结点。 123需要注意区分的：sPool是静态的，为所有该类实例共享。next是非静态的，为该类每个实例单独所有。 HandlerHandler就是消息处理者，它主要用于发送消息和处理消息。发出的消息经过一系列处理，最终会传递到Handler对象的handleMessage()方法中再分门别类的处理。 我们先看一下和发消息相关的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r) &#123; Message m &#x3D; Message.obtain(); m.callback &#x3D; r; return m;&#125;public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis &#x3D; 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue &#x3D; mQueue; if (queue &#x3D;&#x3D; null) &#123; RuntimeException e &#x3D; new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target &#x3D; this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; post(Runnable r)内部封装了一个Message(这个Message的callback被赋值了，在处理消息时来区分交给谁来处理)，最终也是调用了sendMessageAtTime(Message msg, long uptimeMillis)方法。不管是方式1还是方式2，最终都会调用queue.enqueueMessage(msg, uptimeMillis)来将消息添加到消息队列中。 1234567891011121314151617181920212223&#x2F;** * Subclasses must implement this to receive messages. *&#x2F;public void handleMessage(Message msg) &#123;&#125;&#x2F;** * Handle system messages here. *&#x2F;public void dispatchMessage(Message msg) &#123; if (msg.callback !&#x3D; null) &#123;&#x2F;&#x2F;说明是post(Runnable r)，交给run()方法处理 handleCallback(msg); &#125; else &#123; if (mCallback !&#x3D; null) &#123;&#x2F;&#x2F;如果我们创建Handler时传了回调 if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; &#x2F;&#x2F;如果我们创建Handler没有传Callback，那么由这个方法处理，我们需要重新这个方法。 handleMessage(msg); &#125;&#125; dispatchMessage(Message msg)这个方法是在Looper的loop()方法中被调用的。 MessageQueueMessageQueue是消息队列的意思，它主要用来存放发送的消息。通过Handler发送的消息会存入MessageQueue中等待处理，每个线程中只会有一个MessageQuery 对象。 它通过一个单链表的数据结构来维护消息队列的，在插入和删除上比较有优势。我么先看一下插入的过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354boolean enqueueMessage(Message msg, long when) &#123; if (msg.target &#x3D;&#x3D; null) &#123; throw new IllegalArgumentException(&quot;Message must have a target.&quot;); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e &#x3D; new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when &#x3D; when; Message p &#x3D; mMessages; boolean needWake; if (p &#x3D;&#x3D; null || when &#x3D;&#x3D; 0 || when &lt; p.when) &#123; &#x2F;&#x2F; New head, wake up the event queue if blocked. msg.next &#x3D; p; mMessages &#x3D; msg; needWake &#x3D; mBlocked; &#125; else &#123; &#x2F;&#x2F; Inserted within the middle of the queue. Usually we don&#39;t have to wake &#x2F;&#x2F; up the event queue unless there is a barrier at the head of the queue &#x2F;&#x2F; and the message is the earliest asynchronous message in the queue. needWake &#x3D; mBlocked &amp;&amp; p.target &#x3D;&#x3D; null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev &#x3D; p; p &#x3D; p.next; if (p &#x3D;&#x3D; null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake &#x3D; false; &#125; &#125; msg.next &#x3D; p; &#x2F;&#x2F; invariant: p &#x3D;&#x3D; prev.next prev.next &#x3D; msg; &#125; &#x2F;&#x2F; We can assume mPtr !&#x3D; 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; mMessages是链表的头结点，when是消息执行的时间。 如果链表头结点为null(也就是链表空)或者该消息立即执行或者该消息执行的时间比头结点消息执行的时间还早，那么把该消息插入到头结点p的前面，该消息为头结点。 如果不是上面那几种情况，开启了死循环遍历链表。跳出死循环的条件是p == null || when &lt; p.when，也就是说某个节点为null(前一个节点就是末尾了呗)或者该节点消息执行时间大于了该消息的时间。然后将该消息插入到合适的(按执行时间when)节点。 下面看一下取消息的过程，但是我们需要先知道一个概念：消息屏障，也可以说是同步屏障。简单来说，设置了同步屏障之后，Handler只会处理异步消息。因为在next()方法中，会判断忽略同步的消息。那么怎么设置同步屏障呢？postSyncBarrier()方法。 1234567891011121314151617181920212223242526272829303132public int postSyncBarrier() &#123; return postSyncBarrier(SystemClock.uptimeMillis());&#125;private int postSyncBarrier(long when) &#123; &#x2F;&#x2F; Enqueue a new sync barrier token. &#x2F;&#x2F; We don&#39;t need to wake the queue because the purpose of a barrier is to stall it. synchronized (this) &#123; final int token &#x3D; mNextBarrierToken++; final Message msg &#x3D; Message.obtain(); msg.markInUse(); msg.when &#x3D; when; msg.arg1 &#x3D; token; Message prev &#x3D; null; Message p &#x3D; mMessages; if (when !&#x3D; 0) &#123; while (p !&#x3D; null &amp;&amp; p.when &lt;&#x3D; when) &#123; prev &#x3D; p; p &#x3D; p.next; &#125; &#125; if (prev !&#x3D; null) &#123; &#x2F;&#x2F; invariant: p &#x3D;&#x3D; prev.next msg.next &#x3D; p; prev.next &#x3D; msg; &#125; else &#123; msg.next &#x3D; p; mMessages &#x3D; msg; &#125; return token; &#125;&#125; 由源码可见，同步屏障的具体实现是在消息队列中添加了一个target==null的Message。 下面我们来看next()源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114Message next() &#123; &#x2F;&#x2F; Return here if the message loop has already quit and been disposed. &#x2F;&#x2F; This can happen if the application tries to restart a looper after quit &#x2F;&#x2F; which is not supported. final long ptr &#x3D; mPtr; if (ptr &#x3D;&#x3D; 0) &#123; return null; &#125; int pendingIdleHandlerCount &#x3D; -1; &#x2F;&#x2F; -1 only during first iteration int nextPollTimeoutMillis &#x3D; 0; for (;;) &#123; if (nextPollTimeoutMillis !&#x3D; 0) &#123; &#x2F;&#x2F;把绑定在当前线程中的命令，刷新到内核中，用来阻塞线程 Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; &#x2F;&#x2F; Try to retrieve the next message. Return if found. final long now &#x3D; SystemClock.uptimeMillis(); Message prevMsg &#x3D; null; Message msg &#x3D; mMessages; &#x2F;&#x2F;如果设置了同步屏障 if (msg !&#x3D; null &amp;&amp; msg.target &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg &#x3D; msg; msg &#x3D; msg.next; &#x2F;&#x2F;消息为异步则跳出该循环 &#125; while (msg !&#x3D; null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg !&#x3D; null) &#123; if (now &lt; msg.when) &#123;&#x2F;&#x2F;如果该消息的执行执行还没到 &#x2F;&#x2F; Next message is not ready. Set a timeout to wake up when it is ready. &#x2F;&#x2F;设置一个等待时间 nextPollTimeoutMillis &#x3D; (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123;&#x2F;&#x2F;如果该消息执行时间到了 &#x2F;&#x2F; Got a message. mBlocked &#x3D; false; if (prevMsg !&#x3D; null) &#123; prevMsg.next &#x3D; msg.next; &#125; else &#123; &#x2F;&#x2F;那msg肯定是头结点，把头结点的next 赋值给mMessage头结点 mMessages &#x3D; msg.next; &#125; &#x2F;&#x2F;移除当前msg的next指针域的引用 msg.next &#x3D; null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; &#x2F;&#x2F; No more messages. nextPollTimeoutMillis &#x3D; -1; &#125; &#x2F;&#x2F; Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; &#x2F;&#x2F; If first time idle, then get the number of idlers to run. &#x2F;&#x2F; Idle handles only run if the queue is empty or if the first message &#x2F;&#x2F; in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages &#x3D;&#x3D; null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount &#x3D; mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;&#x3D; 0) &#123; &#x2F;&#x2F; No idle handlers to run. Loop and wait some more. mBlocked &#x3D; true; continue; &#125; if (mPendingIdleHandlers &#x3D;&#x3D; null) &#123; mPendingIdleHandlers &#x3D; new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers &#x3D; mIdleHandlers.toArray(mPendingIdleHandlers); &#125; &#x2F;&#x2F; Run the idle handlers. &#x2F;&#x2F; We only ever reach this code block during the first iteration. for (int i &#x3D; 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler &#x3D; mPendingIdleHandlers[i]; mPendingIdleHandlers[i] &#x3D; null; &#x2F;&#x2F; release the reference to the handler boolean keep &#x3D; false; try &#123; keep &#x3D; idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; &#x2F;&#x2F; Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount &#x3D; 0; &#x2F;&#x2F; While calling an idle handler, a new message could have been delivered &#x2F;&#x2F; so go back and look again for a pending message without waiting. nextPollTimeoutMillis &#x3D; 0; &#125;&#125; 有消息可以处理，则取出并移除该消息。如果没有，则阻塞。阻塞方法，主要是通过native层的epoll监听文件描述符的写入事件来实现的。也就是nativePollOnce(ptr, nextPollTimeoutMillis)这个方法。通过Native层的MessageQueue阻塞nextPollTimeoutMillis毫秒的时间。 nextPollTimeoutMillis=-1 一直阻塞不会超时 nextPollTimeoutMillis=0 不会阻塞，立即返回 nextPollTimeoutMillis&gt;0 阻塞nextPollTimeoutMillis毫秒，期间被唤醒则立即返回 我们经常为了防止内存泄漏而调用removeCallbacksAndMessages(Object token)，这个方法内部会调用MessageQueue的下面方法： 1234567891011121314151617181920212223242526272829303132void removeCallbacksAndMessages(Handler h, Object object) &#123; if (h &#x3D;&#x3D; null) &#123; return; &#125; synchronized (this) &#123; Message p &#x3D; mMessages; &#x2F;&#x2F; Remove all messages at front. while (p !&#x3D; null &amp;&amp; p.target &#x3D;&#x3D; h &amp;&amp; (object &#x3D;&#x3D; null || p.obj &#x3D;&#x3D; object)) &#123; Message n &#x3D; p.next; mMessages &#x3D; n; p.recycleUnchecked(); p &#x3D; n; &#125; &#x2F;&#x2F; Remove all messages after front. while (p !&#x3D; null) &#123; Message n &#x3D; p.next; if (n !&#x3D; null) &#123; if (n.target &#x3D;&#x3D; h &amp;&amp; (object &#x3D;&#x3D; null || n.obj &#x3D;&#x3D; object)) &#123; Message nn &#x3D; n.next; n.recycleUnchecked(); p.next &#x3D; nn; continue; &#125; &#125; p &#x3D; n; &#125; &#125;&#125; 从队列中删除所有匹配的元素。先从队首删除，如果删除了则队首指向接下来的元素，重复这个过程，直到第一个不匹配的元素出现。接着从这个元素之后开始查找并删除。 Looper Looper是每个线程中的MessageQueue的管家，每当发现MessageQueue中存在一条消息，就会将它取出，并传递到Handler的dispatchMessage(msg)方法中。每个线程也只会有一个Looper对象。 我们先看一下Looper的创建： 1234567891011121314151617181920212223242526private Looper(boolean quitAllowed) &#123; mQueue &#x3D; new MessageQueue(quitAllowed); mThread &#x3D; Thread.currentThread();&#125;public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() !&#x3D; null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper !&#x3D; null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; sMainLooper &#x3D; myLooper(); &#125;&#125; 我们可以通过prepare(boolean quitAllowed)在子线程中创建一个Looper，quitAllowed参数表示是否允许退出。应用启动的时候已经通过prepareMainLooper()创建了Looper了，不需要也不允许我们再次在主线程中创建。并且提供了一个getMainLooper()来获取主线程的Looper。 Looper最重要的方法就是loop()方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#x2F;** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. *&#x2F;public static void loop() &#123;&#x2F;&#x2F; &#x2F;&#x2F;获取当前Looper对象 因为是ThreadLocal中取出可以的保证拿到的是当前线程的Looper。 final Looper me &#x3D; myLooper(); if (me &#x3D;&#x3D; null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;); &#125; final MessageQueue queue &#x3D; me.mQueue; &#x2F;&#x2F; Make sure the identity of this thread is that of the local process, &#x2F;&#x2F; and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident &#x3D; Binder.clearCallingIdentity(); for (;;) &#123; Message msg &#x3D; queue.next(); &#x2F;&#x2F; might block if (msg &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; No message indicates that the message queue is quitting. return; &#125; &#x2F;&#x2F; This must be in a local variable, in case a UI event sets the logger final Printer logging &#x3D; me.mLogging; if (logging !&#x3D; null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long slowDispatchThresholdMs &#x3D; me.mSlowDispatchThresholdMs; final long traceTag &#x3D; me.mTraceTag; if (traceTag !&#x3D; 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long start &#x3D; (slowDispatchThresholdMs &#x3D;&#x3D; 0) ? 0 : SystemClock.uptimeMillis(); final long end; try &#123; msg.target.dispatchMessage(msg); end &#x3D; (slowDispatchThresholdMs &#x3D;&#x3D; 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag !&#x3D; 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (slowDispatchThresholdMs &gt; 0) &#123; final long time &#x3D; end - start; if (time &gt; slowDispatchThresholdMs) &#123; Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot; + Thread.currentThread().getName() + &quot;, h&#x3D;&quot; + msg.target + &quot; cb&#x3D;&quot; + msg.callback + &quot; msg&#x3D;&quot; + msg.what); &#125; &#125; if (logging !&#x3D; null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; &#x2F;&#x2F; Make sure that during the course of dispatching the &#x2F;&#x2F; identity of the thread wasn&#39;t corrupted. final long newIdent &#x3D; Binder.clearCallingIdentity(); if (ident !&#x3D; newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what&#x3D;&quot; + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; loop()里面获取了当前线程的Looper以及与之关联的MessageQueue。开启了一个死循环，不断地从消息队列MessageQueue拿出消息处理。那么问题就来了。 Question1：这个死循环什么时候退出呢？ 1234queue.next()返回的为null，死循环退出。那么什么时候返回null呢？如果你是在子线程中自己创建的Looper，你可以调用Looper的quit()或者quitSafely()即可退出循环。二者的区别是前者直接退出，后者将消息队列中已有的消息处理完再退出。主线程的Looper呢？很抱歉，Main thread not allowed to quit.主线程的这个死循环退出了应用程序就结束了。 Question2：主线程的Looper开启了loop()死循环，为什么不会卡死？ 1231.首先需要说明的一点是，正是这个死循环保证了应用程序的正常运行。2.Looper.loop() 当消息队列为空时，是阻塞状态。Looper空闲，线程进入阻塞，释放CPU执行权，等待唤醒。当有消息的时候就进行消息处理，然后在这个循环里面去执行的。3.卡死，我们一般说在主线程进行了耗时操作，可能会卡死。四大组件相关等一些操作都是通过Handler机制进行的，如果在主线程进行耗时操作，可能会导致期间其它的事件无法处理，进而卡死。 Question3：从消息队列MessageQueue拿出消息来交给谁处理？ 12由msg.target.dispatchMessage(msg)可以看出，消息交给了msg.target来处理，也就是Handler的实例。 Question4：Message会不会被回收？ 1消息被对应的Handler处理完以后，调用msg.recycleUnchecked();相关源码见上文。 内存泄漏原因：非静态内部类持有外部类的引用。 正确的写法：Handler写成静态的内部类，并持有外部类弱引用。 12345678910111213141516171819202122MyHandler myHandler&#x3D;new MyHandler(this);private static class MyHandler extends Handler &#123; private WeakReference&lt;Context&gt; reference; public MyHandler(Context context) &#123; reference&#x3D;new WeakReference&lt;&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); AccountActivity accountActivity &#x3D; (AccountActivity) reference.get(); &#125;&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); myHandler.removeCallbacksAndMessages(null);&#125; 结束语欢迎留言交流。","link":"","tags":[{"name":"消息机制","slug":"消息机制","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"name":"Handler","slug":"Handler","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/Handler/"}]},{"title":"Hexo+Github搭建你自己的博客","date":"2019-03-08T15:32:23.000Z","path":"2019/03/08/Hexo+Github搭建你自己的博客/","text":"首先，我必须要说的是这绝对是坑，连续坑！网上也有很多相关的文章，但是要么是出奇的千篇一律，要么就是年代久远……我参考了一些文章，搭建了自己的博客，特把相关步骤写下来，希望能帮到你。 我本来不打算写很多概念的东西，但是这既然是一篇博客，还是要装装样子吧。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 我们在搭建博客之前呢，先要确保已经安装了Node.js和Git Node.js的安装 在官网下载最新版本(最新版本！我都是卸载了重新下载的)：https://nodejs.org/en/ 安装 设置路径 1234567891011121314151617181.在安装目录下新建node_cache、node_global两个文件夹2.执行命令npm config set prefix &quot;node_global的全路径&quot;npm config set cache &quot;node_cache的全路径&quot;当然了，如果你不想执行这个命令，也可以直接到C:&#x2F;Users&#x2F;用户名&#x2F;.npmrc这个文件里添加两行代码：prefix&#x3D;node_global的全路径cache&#x3D;node_cache的全路径如：prefix&#x3D;F:\\Android_Tools\\RN_tools\\node_install\\node_globalcache&#x3D;F:\\Android_Tools\\RN_tools\\node_install\\node_cache3.设置环境变量系统--&gt;高级系统设置--&gt;高级--&gt;环境变量变量名：NODE_PATH变量值：node_global的全路径 node -v 查看版本 Git安装 下载新的版本 12可以在官网下载，但是速度是相当的慢。也可以联系我获取。我用的是2.18.0的。 安装 设置环境变量 12变量名：Path变量值：到bin的目录 安装hexo 安装 12$ npm install hexo-cli -g各个博客写的也不太一样，具体可以查看官网https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo 初始化项目 建一个文件夹存放代码，如blog 。然后初始化。这个过程可能会中途一直停在某个时刻，我个人觉得应该是网络的原因。你可以终止操作，删除，重新初始化。 12$ cd blog$ hexo init blog 然后你可以在blog目录下看见初始化的一些文件。 12$ hexo g &#x2F;&#x2F;生成静态文件$ hexo s &#x2F;&#x2F;开启服务 开启服务后，可以在本地浏览器访问http://localhost:4000看到搭建好的博客，主题是默认的。加载的过程可能比较慢，得多等待一会。也可能由于端口占用造成一直加载不出来，这种情况关闭占用这个端口的程序。 修改主题 你可以在官网找喜欢的主题，来替换掉默认的。这里我使用的是hexo-theme-yilia这个主题，点击进入官网。 根据其官网介绍，先下载 1$ git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia 然后修改主题，打开blog目录下的_config.yml，修改theme:yilia 然后 hexo g 重新生成静态文件，至此主题修改完成。 搭建仓库 仓库 需要在github上新建一个仓库，仓库名为：”你的github账户名”.github.io， 比如我的是 gxh-apologize.github.io .将来你的博客地址就是https://“你的github账户名”.github.io 配置ssh key Settings–&gt;SSH and GPG keys–&gt;new SSH key Title可以随意，Key的话需要填id_rsa.pub这个文件里的内容。那么这个文件在哪里呢？ 12$ cd ~&#x2F;. ssh$ ls ls看目录下有没有id_rsa.pub这个文件。有的话可以直接打开复制内容。没有的话输入下面的命令： 1ssh-keygen -t rsa -C &quot;你的github邮箱&quot; 然后连续回车，会生成id_rsa.pub这个文件。 上传代码到仓库 填写仓库信息 blog目录下的_config.yml中填写下面代码，这个文件中有一部分，补全即可。repository根据你仓库实际填写。 1234deploy: type: git repository: git@github.com:gxh-apologize&#x2F;gxh-apologize.github.io.git branch: master 安装hexo-deployer-git插件 在目录blog下执行下面的命令，这个操作我是在git bash操作的。 1npm install hexo-deployer-git --save hexo d 提交 总结我在搭建过程中，确实出现了各种问题，以至于反反复复操作了好几遍才搭建成功。关于是在git bash还是cmd输入命令，我是两者结合的。因为有时候在git bash执行命令会出问题而终止，但是在cmd同样的命令可能又可以了。印象当中安装hexo的命令最后是在cmd完成的。 由于各种原因吧，我遇到的问题没有记录下来。我参考的博客里也记录了几种常见的问题，大家也可以参考。 本人在搭建过程参考了以下文章，非常感谢。 https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html https://blog.51cto.com/13872978/2318972?source=dra 因为图片比较复杂，本文没有出现任何截图。有疑问可留言，也可邮件联系我。 祝大家好运。","link":"","tags":[{"name":"hexo","slug":"hexo","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/github/"},{"name":"博客","slug":"博客","permalink":"https://joeybling.github.io/yilia-plus-demo/tags/%E5%8D%9A%E5%AE%A2/"}]}]